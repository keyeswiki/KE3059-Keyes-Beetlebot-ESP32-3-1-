# Arduino 教程

## 开发环境设置

1. Windows系统：           
![Img](/media/img-20230213142220.png)

1.1. 下载安装Arduino软件：
(1)首先，进入Arduino官方网站：https://www.arduino.cc/ ，点击“**SOFTWARE**”进入下载页面，如下图所示：
![Img](/media/img-20230213142409.png) 
![Img](/media/img-20230213142757.png)

(2)然后，根据你的操作系统选择并下载相应的安装程序。如果你是Windows用户，请选择安装2.0.3版本Arduino IDE，当点击“**Windows** Win10 and newer,64bits”或“**Windows** MSI installer”，代表下载安装文件(.exe) ，需要手动安装; 当点击“**Windows** ZIP file”，代表直接下载2.0.3版本Arduino IDE，是一个压缩文件，解压就可以直接使用，无需安装。
![Img](/media/img-20230213142603.png)

 点击下面图标，就可直接安装Arduino IDE了。
![Img](/media/img-20230213143914.png)

一般情况下，点击“**JUST DOWNLOAD**”就可以下载了，当然如果你愿意，你可以选择小小的赞助，以帮助伟大的Arduino开源事业。

(3)Arduino软件下载完成后,如果你是点击“**Windows** Win10 and newer,64bits”或“**Windows** MSI installer”下载的(.exe)文件“**arduino-ide_2.0.3_Windows_64bit.exe**” ，需要双击(.exe)文件继续安装，当你收到操作系统的警告时，请点击“**Allow access**”允许驱动程序安装。首先点击“**I Agree**”, 然后选择“Anyone who uses this computer(all users)”后再点击Next。
![Img](/media/img-20230213145054.png)
![Img](/media/img-20230213150535.png)
![Img](/media/img-20230213150754.png)

(4)点击“**Next**”后，如果又出现下面页面，点击“**I Agree**”。
![Img](/media/img-20230213150535.png)

(5)选择安装目录(我们建议保持默认目录)，然后点击“**Install**”。
![Img](/media/img-20230213151825.png)

(6)如果出现以下界面，则应选择“**Install**”。
![Img](/media/img-20230213152155.png)

该过程将提取并安装所有必需的文件，以正确执行Arduino软件(IDE)。
![Img](/media/img-20230213152144.png)

(7)安装完成后，会在桌面上生成一个Arduino IDE软件快捷方式。
![Img](/media/img-20230213152457.png)

1.2. 在Windows系统上安装驱动：
（<span style="color: rgb(255, 76, 65);">注意：如果电脑已经安装了驱动程序，则不需要再安装驱动；如果没有，则需要进行以下操作</span>）
在使用ESP32主板之前，必须安装驱动程序，否则ESP32主板将无法与计算机通信。将主控板用USB线连接在电脑上，一般MacOS和Windows10系统的电脑会自动安装驱动。如果没能自动安装，则需要手动安装驱动。

（1）查看电脑是否自动安装好驱动：

点击“**计算机**”--“**属性**”--“**设备管理器**”，显示如下图是安装成功的了：
![Img](/media/img-20230329151628.png)

（2）如果没能自动安装，那就手动安装，步骤如下：

下载CP2102驱动程序的链接：https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads
![Img](/media/img-20230329173622.png)

右键点击“**USB Serial**”，选择“**更新驱动程序(P)**”并点击。
![Img](/media/img-20230329151516.png)

跳转到以下页面，选择“**浏览我的电脑以查找驱动程序(R)**”并点击。
![Img](/media/img-20230329151544.png)
我们在对应的文件夹中也提供有CP210X系列芯片的驱动文件，位置如下：
![Img](/media/img-20230329152927.png)
你可以先将驱动文件复制到电脑桌面上，然后点击“**浏览(R)...**”,选中CP210X系列芯片的驱动，最后点击“**下一页**”。
![Img](/media/img-20230329152620.png)

过一会儿，驱动安装成功。
![Img](/media/img-20230329152721.png)

这个时候再打开计算机设备管理器，就可以看到CP2102驱动程序已经安装成功了，刚刚那个黄色的感叹号不见了。
![Img](/media/img-20230329151628.png)

1.3. Arduino IDE工具栏介绍：
**点击电脑桌面上的图标![Img](/media/img-20230329153500.png)，打开Arduino IDE。**
![Img](/media/img-20230329154622.png)

![Img](/media/img-20230213155549.png) -- 用于检查是否存在任何编译错误。
![Img](/media/img-20230213155615.png) -- 用于将程序上传到Arduino板。
![Img](/media/img-20230213155649.png) -- 用于编写程序时的单步调试。
![Img](/media/img-20230213155721.png) -- 用于从板接收串行数据并将串行数据发送到板的串行监视器。
![Img](/media/img-20230213155746.png) -- 用于串口接收的数据转换成动态曲线图。
![Img](/media/img-20230213155821.png) -- 用于打开最近保存的示例草图。
![Img](/media/img-20230213155849.png) -- 用手动安装开发板。

**语言切换功能：**
（1）单击“File”→“Preferences”，在 Preferences 页面中将语言“English”切换成“简体中文”，点击“OK”就可以了。
![Img](/media/img-20230329155004.png)
![Img](/media/img-20230329155319.png)
![Img](/media/img-20230329155412.png)


1.4. 在Arduino IDE上安装ESP32：
上面已经学习了怎么下载ArduinoIDE和怎么安装驱动，那下面就要在Arduino IDE上安装ESP32，请执行以下步骤：
<span style="color: rgb(255, 76, 65);">特别注意：你需要Arduino IDE 1.8.5或更高版本才能在其上安装ESP32。</span>
(1)点击电脑桌面上的图标![Img](/media/img-20230329153500.png)，打开Arduino IDE。
![Img](/media/img-20230329155546.png)
(2)点击“文件” →“首选项”，如下图：
![Img](/media/img-20230329155723.png)
(3)打开下图标出的按钮
![Img](/media/img-20230329160024.png)
(4)将这个地址：https://dl.espressif.com/dl/package_esp32_index.json ，复制粘贴到里面去再点击“**确定**”保存这个地址，如下图：
![Img](/media/img-20230329160216.png)
(5)再点击“**确定**”。
![Img](/media/img-20230329160326.png)
（6）先点击“**工具**”→“**开发版:**”，，再点击“**开发版管理器...**”进入“**开发版管理器**”页面，在文本框中输入“**esp32**”，选择最新版本进行安装，安装包不大，点击“**安装**”开始安装相关安装包。如下图。
![Img](/media/img-20230425140528.png)
![Img](/media/img-20230425140644.png)
![Img](/media/img-20230425140913.png) 
（7）点击“**工具**”→“**开发版:**”，就可以看到安装好的ESP32 Arduino，你可以在里面查看到各种不同型号ESP32开发板，选择对应的ESP32开发板型号。
![Img](/media/img-20230329165501.png)
![Img](/media/img-20230329165527.png)
（8）设置好板型后，再选择正确的COM口（安装驱动成功后可看到对应COM口），设置如下图。
![Img](/media/img-20230329151628.png)
![Img](/media/img-20230329165744.png)
![Img](/media/img-20230329165919.png)

2.Mac系统:
![Img](/media/img-20230518094533.png)

2.1.下载安装Arduino IDE:
进入Arduino官方网站：https://www.arduino.cc/ ，点击“**SOFTWARE**”进入下载页面，如下图所示：
![Img](/media/img-20230329170942.png)

2.2.如何安装CP2102驱动程序：
（<span style="color: rgb(255, 76, 65);">注意：如果已经安装了驱动程序，则不需要再安装驱动；如果没有，则需要进行以下操作</span>）
（1）用USB线将ESP32主板连接到你的MacOS系统电脑上，并打开Arduino IDE。
![Img](/media/img-20230505164202.png)

（2）CP2102驱动下载链接：
https://cn.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads
（3）点击下载MacOS 版本。
![Img](/media/img-20230329173702.png)

（4）解压下载好的压缩包。
![Img](/media/img-20230329173510.png)

（5）打开文件夹，双击“SiLabsUSBDriverDisk.dmg”文件。
![Img](/media/img-20230329173728.png)
可以看到以下文件。
![Img](/media/img-20230329173738.png)
（6）双击“Install CP210x VCP Driver”，勾选“Don’t warn me when opening application on this disk image”并单击“Open”。
![Img](/media/img-20230329173804.png)
（7）单击“Continue”。
![Img](/media/img-20230329173816.png)
（8）先点击“Agree”，然后点击“Continue”。
![Img](/media/img-20230329173824.png)
（9）继续点击“Continue”，然后输入你的用户密码
![Img](/media/img-20230329173832.png)
![Img](/media/img-20230329173836.png)
（10）选择“Select Open Security Preferences”。
![Img](/media/img-20230329173845.png)
（11）点击安全锁，输入你的用户密码来授权。
![Img](/media/img-20230329173854.png)
![Img](/media/img-20230329173858.png)
（12）看到锁被打开了，点击“Allow”。
![Img](/media/img-20230329173907.png)
（13）回到安装界面，根据提示等待安装.
![Img](/media/img-20230329173914.png)
（14）安装成功
![Img](/media/img-20230329173923.png)

2.3. 在Arduino IDE上安装ESP32：
上面已经学习了怎么下载ArduinoIDE和怎么安装驱动，那下面就要在Arduino IDE上安装ESP32，请执行以下步骤：
<span style="color: rgb(255, 76, 65);">特别注意：你需要Arduino IDE 1.8.5或更高版本才能在其上安装ESP32。</span>
(1)点击电脑桌面上的图标![Img](/media/img-20230329153500.png)，打开Arduino IDE。先切换语言，然后点击“Arduino IDE” →“首选项”，如下图：
![Img](/media/img-20230424101946.png)
(2)打开下图标出的按钮
![Img](/media/img-20230424102212.png)
(3)将这个地址：https://dl.espressif.com/dl/package_esp32_index.json ，复制粘贴到里面去再点击“**确定**”保存这个地址，如下图：
![Img](/media/img-20230424102411.png)
(4)再点击“**确定**”。
![Img](/media/img-20230424102712.png)
（5）先点击“**工具**”→“**开发版:**”，，再点击“**开发版管理器...**”进入“**开发版管理器**”页面，在文本框中输入“**esp32**”，选择最新版本进行安装，安装包不大，点击“**安装**”开始安装相关安装包。如下图。
![Img](/media/img-20230425142725.png)
![Img](/media/img-20230425142848.png)
![Img](/media/img-20230425142933.png)
（6）点击“**工具**”→“**开发版:**”，就可以看到安装好的ESP32 Arduino，你可以在里面查看到各种不同型号ESP32开发板，选择对应的ESP32开发板型号。这里是以“ESP32 Wrover Module”为例。
![Img](/media/img-20230424103120.png)

（7）设置好板型后，再选择正确的COM口（安装驱动成功后可看到对应COM口），设置如下图。
![Img](/media/img-20230424105011.png)

3.添加arduino库文件

我们提供的Arduino 库文件是放在资料的“**3. Arduino 教程 > 1. 开发环境设置 > 3. Arduino 库文件**”文件夹中，如下图：
![Img](/media/img-20230403171753.png)

3.1. Windows系统添加库文件的方法：

（1）打开Arduino IDE![Img](/media/img-20230403171853.png)，在Arduino IDE界面点击“**项目**”→“**包含库**”→“**添加.ZIP库...**”。
![Img](/media/img-20230403170831.png)

（2）找到库文件存放的位置，选中对应的库文件，点击“**打开**”添加即可。库文件只能一个一个的添加。（<span style="color: rgb(255, 76, 65);">注意：库文件需要压缩为 **.ZIP**格式，我们在文件夹中是以 **.ZIP** 格式提供有；这里以“**Adafruit_NeoPixel-1.3.5.ZIP**”为演示，其他库文件的添加方法是一样的。</span>）
![Img](/media/img-20230403171418.png)

3.2. MacOS系统的库文件添加方法: 
（1）arduino IDE界面选择“**项目**” > “**包含库**” > “**添加.ZIP库...**”。
![Img](/media/img-20230424110521.png)

（2）找到库文件存放的位置，选中对应的库文件，再点击**打开**，库文件只能一个一个的添加。（<span style="color: rgb(255, 76, 65);">这里以添加“Adafruit_NeoPixel-1.3.5.ZIP”库文件为例，其他库文件的添加方法一样</span>），如下图：
![Img](/media/img-20230403171753.png)
![Img](/media/img-20230424111056.png)

到这，正常是安装成功的了。



## Beetlebot ESP32 3合1 智能小车初始形态安装步骤
![Img](/media/img-20230403160548.png)

 安装1

安装所需零件：
![Img](/media/img-20230403160628.png)

安装：
![Img](/media/img-20230403160639.png)

完成：
![Img](/media/img-20230403160651.png)

 安装2

安装所需零件：
![Img](/media/img-20230403160715.png)

安装：
![Img](/media/img-20230403160726.png)

完成：
![Img](/media/img-20230403160738.png)

 安装3

安装所需零件：
![Img](/media/img-20230403160945.png)

安装：
![Img](/media/img-20230403160957.png)

完成：
![Img](/media/img-20230403161008.png)

 安装4

安装所需零件：
![Img](/media/img-20230403161032.png)

安装：
![Img](/media/img-20230403161044.png)

完成：
![Img](/media/img-20230403161056.png)

 安装5

安装所需零件：
![Img](/media/img-20230403161121.png)

<span style="color: rgb(255, 76, 65);">先将电机、8*8点阵屏和上下pcb板的连接线都接上。</span>

|左电机|右电机|
| :--: | :--: |
|**L**|**R**|

![Img](/media/img-20230508105400.png)

|8*8点阵|小车PCB板|
| :--: | :--: |
|G|G|
|5V|5V|
|SDA|SDA|
|SCL|SCL|
![Img](/media/img-20230508111302.png)
![Img](/media/img-20230508105414.png)

安装：
![Img](/media/img-20230508112106.png)

完成：
![Img](/media/img-20230403161648.png)

 安装6

安装所需零件：
![Img](/media/img-20230403161716.png)

安 装：
![Img](/media/img-20230403161733.png)

完成：
![Img](/media/img-20230403161752.png)

 安装7

安装所需零件：
![Img](/media/img-20230403161815.png)

安装：
![Img](/media/img-20230403162348.png)

完成：
![Img](/media/img-20230403162403.png)

 安装8

安装所需零件：
![Img](/media/img-20230403162701.png)

安装：
![Img](/media/img-20230403162930.png)

完成：
![Img](/media/img-20230403162721.png)

 安装9

安装所需零件：
![Img](/media/img-20230403163656.png)

<span style="color: rgb(255, 76, 65);">安装前需要调节舵机角度为90°。</span>

|舵机|小车PCB板|
| :--: | :--: |
|棕线| G |
| 红线 | 5V |
| 橙黄线 | S1（GPIO4）|
![Img](/media/img-20230508091835.png)

```
include <Arduino.h>
// 舵机通道 
int channel_PWM = 3;  
// 舵机频率，那么周期也就是1/50，也就是20ms ，PWM一共有16个通道，0-7位高速通道由80Mhz时钟驱动，后面8个为低速通道由1Mhz时钟驱动.
int freq_PWM = 50;   
// PWM分辨率，取值为 0-20 之间  ，这里填写为10，那么后面的ledcWrite这个里面填写的pwm值就在0 - 2的10次方 之间 也就是 0-1024 ，如果是要求不高的东西你可以直接拿1000去算了.
int resolution_PWM = 10;   
// 绑定的IO，在下面的绑定函数里面会用到，绑定之后这个IO就会变成我们PWM的输出口.
const int PWM_Pin = 4;  //指定pwm绑定到GPIO4输出.
void setup() {
  ledcSetup(channel_PWM, freq_PWM, resolution_PWM); // 设置舵机通道,舵机频率,PWM分辨率.
  ledcAttachPin(PWM_Pin, channel_PWM);  //将LEDC通道绑定到指定 IO 口上以实现输出
}
void loop() {
  ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，此时舵机角度为90°.
}

```
上面的Arduino代码在资料中有提供，打开舵机的调整代码并烧录到Beetlebot的ESP32主板，完成。代码如下图位置：
![Img](/media/img-20230425083450.png)

调整之后，正向前安装：
![Img](/media/img-20230403164300.png)

完成：
![Img](/media/img-20230403164312.png)

 安装10

安装所需零件：
![Img](/media/img-20230403164357.png)

安装：
![Img](/media/img-20230403164606.png)

完成：
![Img](/media/img-20230403164628.png)

 安装11

安装所需零件：
![Img](/media/img-20230403164712.png)

安装：
![Img](/media/img-20230403164750.png)

完成：
![Img](/media/img-20230403164808.png)

 初始形态接线图

超声波接线图：
|超声波传感器| 小车PCB板 |
| :--: | :--: |
|Vcc|5V|
|Trig|S2（GPIO5）|
|Echo|S1（GPIO18）|
| Gnd |G|
![Img](/media/img-20230508100004.png)
![Img](/media/img-20230505145136.jpg)

云台舵机接线图：
| 舵机 | 小车PCB板 |
| :--: | :--: |
| 棕线 | G |
| 红线 | 5V |
| 橙黄线 | S1（GPIO4） |
![Img](/media/img-20230508091835.png)
![Img](/media/img-20230505145537.jpg)

左边光敏接线图：
|左边光敏传感器| 小车PCB板 |
| :--: | :--: |
| G| G |
| V| V |
|S|S（GPIO34）|
![Img](/media/img-20230508101203.png)
![Img](/media/img-20230505150208.png)
![Img](/media/img-20230505150639.jpg)

右边光敏接线图：
|右边光敏传感器| 小车PCB板 |
| :--: | :--: |
| G| G |
| V| V |
|S|S（GPIO35）|
![Img](/media/img-20230508101729.png)
![Img](/media/img-20230505151028.jpg)
![Img](/media/img-20230505151526.jpg)

 原型态安装完成示意图：
![Img](/media/img-20230506135431.png)




## 项目教程



### 项目01: SK6812 RGB

1.实验简介：
小车扩展板上有4个RGB LED，RGB LED属于简单的发光模块，可以通过调节色彩调出不同颜色的灯效，可广泛应用于建筑物、桥梁、道路、花园、庭院、地板等领域的装饰照明与会场布置、圣诞节、万圣节、情人节、复活节、国庆节等节日期间烘托气氛等场景。在本实验中，使小车扩展板上的4个RGB实现各种灯光效果。

2.元件知识：
**SK6812RGB：** 小车扩展板上有4个RGB LED，从原理图中可以看出，这4个RGBLED都是串联起来的，在电压电流充足的情况下可以接几百个RGB LED，都可以用一根信号线控制任意一个RGB LED，并且让它显示任意一种颜色。每一颗RGBLED都是一个独立的像素点，每个像素点都是由R、G、B三基色颜色组成，可实现256级亮度显示，完成16777216种颜色的全真色彩显示，同时像素点内部包含了智能数字接口数据锁存信号整形放大驱动电路，还内置信号整形电路，有效保证了像素点光的颜色高度一致。
![Img](/media/img-20230330090513.png)

3.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“<span style="color: rgb(0, 209, 0);">Adafruit_NeoPixel</span>”，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

4.实验代码：
小车PCB板上的SK6812RGB是由ESP32主板上的GPIO 14 控制。

```
//*************************************************************************************
/*
  项目 01 SK6812 RGB
  4个rgb用于各种灯光效果
*/
###include <Adafruit_NeoPixel.h>

###define PIN 14

// 参数1 =条带像素数
// 参数2 = Arduino引脚号(大部分有效)
// 参数3 =像素类型标志，根据需要添加在一起:
//   NEO_KHZ800  800 KHz比特流(大多数NeoPixel产品带WS2812 led)
//   NEO_KHZ400  400 KHz(经典的“v1”(不是v2) FLORA像素，WS2811驱动器)
//   NEO_GRB     像素连接到GRB位流(大多数NeoPixel产品)
//   NEO_RGB     像素连接到RGB位流(v1 FLORA像素，而不是v2)
Adafruit_NeoPixel strip = Adafruit_NeoPixel(60, PIN, NEO_GRB + NEO_KHZ800);

// 重要提示:为了降低NeoPixel烧毁风险，在像素电源引线上添加1000 uF电容，在第一个像素的数据输入上添加
// 300 - 500欧姆电阻，并最小化Arduino与第一个像素之间的距离。避免在带电电路上连接。如果必须，请先连接GND。

void setup() {
  strip.begin();
  strip.show(); // 将所有像素初始化为“off”
}

void loop() {
  // 一些示例程序显示如何显示到像素:
  colorWipe(strip.Color(255, 0, 0), 50); // 红
  colorWipe(strip.Color(0, 255, 0), 50); // 绿
  colorWipe(strip.Color(0, 0, 255), 50); // 蓝
  // 发送一系列像素追逐…
  theaterChase(strip.Color(127, 127, 127), 50); // 白
  theaterChase(strip.Color(127,   0,   0), 50); // 红
  theaterChase(strip.Color(  0,   0, 127), 50); // 蓝

  rainbow(20);
  rainbowCycle(20);
  theaterChaseRainbow(50);
}

// 用颜色一个接一个地填充圆点
void colorWipe(uint32_t c, uint8_t wait) {
  for(uint16_t i=0; i<strip.numPixels(); i++) {
      strip.setPixelColor(i, c);
      strip.show();
      delay(wait);
  }
}

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256; j++) {
    for(i=0; i<strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel((i+j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

// 稍有不同的是，这使得彩虹均匀地分布在各处
void rainbowCycle(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256*5; j++) { // 5轮所有颜色
    for(i=0; i< strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

//剧院风格的爬行灯.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10; j++) {  //做10个循环的追逐
    for (int q=0; q < 3; q++) {
      for (int i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, c);    //每三个像素打开
      }
      strip.show();
     
      delay(wait);
     
      for (int i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //每3个像素关闭
      }
    }
  }
}

//带有彩虹效果的剧院式爬行灯
void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // 来回循环所有256种颜色
    for (int q=0; q < 3; q++) {
        for (int i=0; i < strip.numPixels(); i=i+3) {
          strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //每三个像素打开
        }
        strip.show();
       
        delay(wait);
       
        for (int i=0; i < strip.numPixels(); i=i+3) {
          strip.setPixelColor(i+q, 0);        //每3个像素关闭
        }
    }
  }
}

// 输入一个0到255的值来获得颜色值.
// 这些颜色是r - g - b -回到r.
uint32_t Wheel(byte WheelPos) {
  if(WheelPos < 85) {
   return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  } else if(WheelPos < 170) {
   WheelPos -= 85;
   return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  } else {
   WheelPos -= 170;
   return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
}
//*************************************************************************************
```

5.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)，如下图所示：</span>），利用USB线上电后，小车PCB板上的4个RGB LED发出各种颜色灯光效果。
![Img](/media/img-20230330093000.png)
![Img](/media/img-20230331092416.png)












### 项目02: 演奏音乐

1.实验简介：
小车扩展板上有个喇叭功放元件，它常用来播放音乐，作为一些音乐播放设备的外接扩音设备。
在本实验中，我们利用喇叭功放元件来播放一首音乐。

2.元件知识：
喇叭功放元件：喇叭功放元件（原理相当于无源蜂鸣器），其内部不带震荡电路，控制时需要在元件正极输入不同频率的方波，负极接地，从而控制喇叭功放元件响起不同频率的声音。

3.实验代码：
小车PCB板上的喇叭功放元件是由ESP32主板上的GPIO 2 控制。

```
//*************************************************************************************
/*
项目 02 演奏音乐
蜂鸣器播放音乐
*/
###define LEDC_CHANNEL_0 0

// LEDC定时器使用13位精度

###define LEDC_TIMER_13_BIT  13

// 定义工具IO口

###define BUZZER_PIN  2

//创建音乐旋律列表，超级玛丽

int melody[] = {330, 330, 330, 262, 330, 392, 196, 262, 196, 165, 220, 247, 233, 220, 196, 330, 392, 440, 349, 392, 330, 262, 294, 247, 262, 196, 165, 220, 247, 233, 220, 196, 330, 392,440, 349, 392, 330, 262, 294, 247, 392, 370, 330, 311, 330, 208, 220, 262, 220, 262,

294, 392, 370, 330, 311, 330, 523, 523, 523, 392, 370, 330, 311, 330, 208, 220, 262,220, 262, 294, 311, 294, 262, 262, 262, 262, 262, 294, 330, 262, 220, 196, 262, 262,262, 262, 294, 330, 262, 262, 262, 262, 294, 330, 262, 220, 196};

//创建音调持续时间列表

int noteDurations[] = {8,4,4,8,4,2,2,3,3,3,4,4,8,4,8,8,8,4,8,4,3,8,8,3,3,3,3,4,4,8,4,8,8,8,4,8,4,3,8,8,2,8,8,8,4,4,8,8,4,8,8,3,8,8,8,4,4,4,8,2,8,8,8,4,4,8,8,4,8,8,3,3,3,1,8,4,4,8,4,8,4,8,2,8,4,4,8,4,1,8,4,4,8,4,8,4,8,2};
void setup() {
pinMode(BUZZER_PIN, OUTPUT); // 设置蜂鸣器为输出模式
}

void loop() {

  int noteDuration; //创建变量noteDuration

  for (int i = 0; i < sizeof(noteDurations); ++i)

  {
      noteDuration = 800/noteDurations[i];

      ledcSetup(LEDC_CHANNEL_0, melody[i]*2, LEDC_TIMER_13_BIT);

      ledcAttachPin(BUZZER_PIN, LEDC_CHANNEL_0);

      ledcWrite(LEDC_CHANNEL_0, 50);

      delay(noteDuration * 1.30); //延时
  }
}
//*************************************************************************************
```
4.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)，如下图所示：</span>），利用USB线上电后，小车PCB板上的喇叭功放元件就开始播放一首音乐。
![Img](/media/img-20230330093000.png)
### 项目03: 点阵屏
![Img](/media/img-20230518082838.png)

1.实验简介：
8×8 点阵屏通过LED(发光二极管）组成，以灯珠亮灭来显示文字、图片、动画、视频等，8×8 点阵显示屏制作简单，安装方便，被广泛应用于各种公共场合，如汽车报站器、广告屏、银行窗口屏、叫号屏以及停车系统等等。在本实验中，将使用8×8 点阵屏来显示图案。

2.元件知识：
**8×8点阵屏：** LED点阵屏按照LED发光颜色可分为单色、双色、三色灯等，可显示红、黄、绿甚至是真彩色。根据LED的数量又分为4×4、8×8、16×16等不同类型。这里我们通过单色8×8点阵屏来了解其原理。
不同点阵屏封装不同，8×8点阵屏由8行8列共64个LED灯组成，其内部结构如下图：
![Img](/media/img-20230330094132.png)
每个LED放置在行线和列线的交叉点上，当对应的某一行电平拉高，某一列电拉低，则对应交叉点的LED就会点亮。8×8点阵屏有16个管脚，将有丝印的一边朝下，逆时针编号为1-8，9-16。
![Img](/media/img-20230330094146.png)
其对应内部管脚定义如下如所示：
![Img](/media/img-20230330094300.png)
比如我们要点亮第一行第一列LED灯，则对应将点阵屏的第9脚拉高，第13脚拉低，其他LED控制以此类推即可。
**HT16K33 8X8点阵驱动模块：** 上面介绍了8*8点阵的原理，想控制8*8点阵需要多达16个单片机的引脚。这样既浪费资源也浪费时间。这里用了一个驱动点阵屏的芯片：HT16K33。HT16K33是一款内存映射和多功能LED控制器驱动芯片。利用HT16K33芯片驱动1个8*8点阵，只需要利用单片机的I2C通信端口控制点阵，大大的节约了单片机资源。下图是HT16K33 芯片工作原理图。
![Img](/media/img-20230330094419.png)
我们基于以上原理设计了一个8X8点阵驱动模块，从上图我们可以看出，我们只要通过I2C 通讯利用单片机的2个引脚就可以很好的控制点阵显示。
**8X8点阵模块的参数：**
- 工作电压: 5V    
- 额定输入频率: 400KHZ 
- 输入功率: 2.5W  
- 输入电流: 500mA  
**取模工具的使用说明：**
点阵和驱动的原理都已经介绍完了，那点阵上显示的内容是怎么来的呢，有没有比较简便的方法？这里给大家介绍一款点阵取模工具，这块工具使用的是在线版，链接：http://dotmatrixtool.com/#
现在就一起看看怎么使用吧。
①打开链接如下图：
![Img](/media/img-20230330094531.png)
②我们的点阵是8X8的，所以调整高度为8，宽度为8，如下图：
![Img](/media/img-20230330094541.png)
③在Endian 这里选择Big Endian(MSB)这个模式
![Img](/media/img-20230330094552.png)
④将图案生成16进制的数据
如下图，按鼠标左键选中，右键取消，画好自己想要的图案，点击<span style="color: rgb(255, 76, 65);">Generate</span>，就会生成我们所需要的十六进制的数据了，这里是以下面的图案为例的。
![Img](/media/img-20230518104321.png)
这个生成的十六进制的代码（0x22, 0x14, 0x48, 0x40, 0x40, 0x48, 0x14, 0x22）就是点阵需要显示的内容，如果想要点阵显示这样的图案，则需要将这十六进制的代码放到程序里面。

3.实验接线：
| 8X8点阵 | 小车PCB板 |
| :--: | :--: |
| G | G |
| 5V | 5V |
| SDA | SDA |
| SCL | SCL |
![Img](/media/img-20230508111302.png)

4.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“<span style="color: rgb(0, 209, 0);">HT16K33_Lib_For_ESP32</span>”，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

5.实验代码：
8X8点阵是由ESP32主板的GPIO21（SDA），GPIO22（SCL）控制。

```
//*************************************************************************************
/*
 项目 03 8X8 点阵
 8*8点阵屏幕显示图案
*/
###include "HT16K33_Lib_For_ESP32.h"
###define SDA 21
###define SCL 22
ESP32_HT16K33 matrix = ESP32_HT16K33();
byte test1[8] = {0x22, 0x14, 0x48, 0x40, 0x40, 0x48, 0x14, 0x22};

void setup()
{
  matrix.init(0x70, SDA, SCL);//初始化矩阵
  matrix.showLedMatrix(test1,0,0);
  matrix.show();
}

void loop()
{
  for (int i = 0; i <= 7; i++)
  {
    matrix.setBrightness(i);
    delay(100);
  }
  for (int i = 7; i > 0; i--)
  {
    matrix.setBrightness(i);
    delay(100);
  }
}
//*************************************************************************************
```
6.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)，如下图所示：</span>），利用USB线上电后，小车前的8*8点阵屏显示对应图案。
![Img](/media/img-20230330093000.png)














### 项目04: 舵机转动

1.实验简介：
小车上有两个舵机，这里以接在引脚GPIO4的舵机为例，舵机是一种可以非常精确地旋转的电机。目前已广泛应用于玩具车、遥控直升机、飞机、机器人等领域。在这个项目中，我们将使用ESP32主板控制舵机转动。
2.元件知识：
![Img](/media/img-20230330095339.png)
**舵机：** 舵机是一种位置伺服的驱动器，主要是由外壳、电路板、无核心马达、齿轮与位置检测器所构成。其工作原理是由接收机或者单片机发出信号给舵机，其内部有一个基准电路，产生周期为20ms，宽度为1.5ms 的基准信号，将获得的直流偏置电压与电位器的电压比较，获得电压差输出。经由电路板上的IC 判断转动方向，再驱动无核心马达开始转动，透过减速齿轮将动力传至摆臂，同时由位置检测器送回信号，判断是否已经到达定位。适用于那些需要角度不断变化并可以保持的控制系统。当电机转速一定时，通过级联减速齿轮带动电位器旋转，使得电压差为0，电机停止转动。
舵机有多种规格，但它们都有三根连接线，分别是棕色、红色、橙色(不同品牌可能有不同的颜色)。棕色为GND，红色为电源正极，橙色为信号线
![Img](/media/img-20230324190535.png)
舵机的伺服系统由可变宽度的脉冲来进行控制，橙色的控制线是用来传送脉冲的。一般而言，PWM控制舵机的基准信号周期为20ms（50Hz），理论上脉宽应在1ms到2ms之间，对应控制舵机角度是0°～180°。但是，实际上更多控制舵机的脉宽范围是0.5ms 到2.5ms，具体需要自己实际调试下。
![Img](/media/img-20230324190601.png)
经过实测，舵机的脉冲范围为0.65ms~2.5ms。180度舵机，对应的控制关系是这样的：
|高电平时间|舵机角度|基准信号周期时间（20ms）|
| :--: | :--: | :--: |
|0.65ms|0度|0.65ms高电平+19.35ms低电平|
|1.5ms|90度|1.5ms高电平+18.5ms低电平|
|2.5ms|180度|2.5ms高电平+17.5ms低电平|

舵机的规格参数：
|工作电压：|DC 4.8V〜6V|
| :--: | :--: |
|可操作角度范围：|可操作角度范围：|
|脉波宽度范围：|500→2500 μsec|
|外观尺寸：|22.9*12.2*30mm|
|空载转速：|0.12±0.01 sec/60度（DC 4.8V）  0.1±0.01 sec/60度（DC 6V）|
|空载电流：|200±20mA（DC 4.8V）  220±20mA（DC 6V）|
|停止扭力：|1.3±0.01kg·cm（DC 4.8V）  1.5±0.1kg·cm（DC 6V）|
|停止电流：|≦850mA（DC 4.8V）  ≦1000mA（DC 6V）|
|待机电流：|3±1mA（DC 4.8V）  4±1mA（DC 6V）|
|重量:|9±1g (不带舵机轴)|
|使用温度：|-30℃~60℃|

3.实验接线：
| 舵机 | 小车PCB板 |
| :--: | :--: |
| 棕线 | G |
| 红线 | 5V |
| 橙黄线 | S1（GPIO4） |
![Img](/media/img-20230508091835.png)

4.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“<span style="color: rgb(0, 209, 0);">ESP32Servo</span>”，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

5.实验代码1：
控制超声波传感器转动的舵机是由ESP32主板的 GPIO4 控制。

```
//*************************************************************************************
/*
项目 04.1 舵机转动
舵机塑料臂将以0°、45°、90°、135°、180°的角度反复旋转
*/
###include <Arduino.h> 

// 舵机通道 
int channel_PWM = 3;  
// 舵机频率，那么周期也就是1/50，也就是20ms ，PWM一共有16个通道，0-7位高速通道由80Mhz时钟驱动，后面8个为低速通道由1Mhz时钟驱动.
int freq_PWM = 50;   
// PWM分辨率，取值为 0-20 之间  ，这里填写为10，那么后面的ledcWrite这个里面填写的pwm值就在0 - 2的10次方 之间 也就是 0-1024 ，如果是要求不高的东西你可以直接拿1000去算了.
int resolution_PWM = 10;   
// 绑定的IO，在下面的绑定函数里面会用到，绑定之后这个IO就会变成我们PWM的输出口.
const int PWM_Pin = 4;  //指定pwm绑定到GPIO4输出.

void setup() {
  Serial.begin(115200); //设置波特率为115200.
  ledcSetup(channel_PWM, freq_PWM, resolution_PWM); // 设置舵机通道,舵机频率,PWM分辨率.
  ledcAttachPin(PWM_Pin, channel_PWM);  //将LEDC通道绑定到指定 IO 口上以实现输出
}

void get_pwm_info()
{
  Serial.println("*******************************************************************");
  Serial.print("Reads the value of the specified channel duty cycle：");
  Serial.println(ledcRead(channel_PWM));  //读取指定通道占空比的值
  Serial.print("Reads the value of the specified channel frequency as：");
  Serial.println(ledcReadFreq(channel_PWM));  //返回指定通道当前频率（如果当前占空比为0 则该方法返回0).
}

void loop() {
  ledcWrite(channel_PWM, 25);  //20ms高电平为0.5ms左右 ，也就是0.5/20*1024，此时舵机角度为0°.
  get_pwm_info();  //打印信息，点击IDE右上角的串口查看器就可以看到打印的内容了
  delay(1000);
  ledcWrite(channel_PWM, 52);  //20ms高电平为1ms左右 ，也就是1/20*1024，此时舵机角度为45°.
  get_pwm_info();  //打印信息，点击IDE右上角的串口查看器就可以看到打印的内容了
  delay(1000);
  ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，此时舵机角度为90°.
  get_pwm_info();
  delay(1000);
  ledcWrite(channel_PWM, 102);  //20ms高电平为2ms左右 ，也就是2/20*1024，此时舵机角度为135°.
  get_pwm_info();
  delay(1000);
  ledcWrite(channel_PWM, 128);  //20ms高电平为2.5ms左右 ，也就是2.5/20*1024，此时舵机角度为180°.
  get_pwm_info();
  delay(1000);
  //ledcDetachPin(PWM_Pin);  //这个是解除IO口的pwm输出功能模式.
}
//*************************************************************************************
```
6.实验现象1：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>）， 利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，串口监视器窗口打印指定通道占空比的值和指定通道当前频率值，同时舵机塑料臂将以0°、45°、90°、135°、180°的角度转动。循环进行！！

![Img](/media/img-20230330103315.png)

其实我们还可以有一种更简单的方法控制舵机，就是使用Arduino ESP32的舵机库文件，可以参考Arduino 官方的使用说明：https://www.arduino.cc/en/Reference/Servo 。
以下是使用了舵机库文件的程序代码。

7.实验代码2：

```
//*************************************************************************************
/*
项目 04.2 舵机转动
舵机将从0度旋转到180度，然后反转使它从180度旋转到0度的方向不断地重复这些动作.
*/
###include <ESP32Servo.h>

Servo myservo;  // 创建舵机对象来控制舵机

int posVal = 0;    // 创建变量来存储舵机位置
int servoPin = 4; // 舵机引脚

void setup() {
  myservo.setPeriodHertz(50);           // 标准50赫兹舵机
  myservo.attach(servoPin, 500, 2500);  // 将servoPin上的舵机附加到舵机对象上
}
void loop() {

  for (posVal = 0; posVal <= 180; posVal += 1) { // 从0°到180°
    // 以1度为阶梯
    myservo.write(posVal);       // 告诉舵机进入可变'pos'位置
    delay(15);                   // 等待15ms舵机到达位置
  }
  for (posVal = 180; posVal >= 0; posVal -= 1) { // 从180°到0°
    myservo.write(posVal);       // 告诉舵机进入可变'pos'位置
    delay(15);                   // 等待15ms舵机到达位置
  }
}
//*************************************************************************************
```

8.实验现象2：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot按钮，出现上传进度百分比再松开Boot按钮![Img](/media/img-20230331144331.png)，如下图所示：</span>），利用USB线上电后，舵机塑料臂将从0度旋转到180度，然后反转方向，使其从180度旋转到0度，循环往复地重复这些动作。




### 项目05: 电机驱动和调速

1.实验简介：
驱动电机的方法有很多，我们这个小车用到的是最常用的DRV8833电机驱动芯片，该芯片为玩具、打印机及其它电机一体化应用提供了一款双通道桥式电动驱动器解决方案。
在本实验中，我们使用扩展板上的DRV8833电机驱动芯片驱动小车的两个直流电机，通过编写代码实现小车分别向前，向后，向左，向右行走的效果。

2.元件知识：
**DRV8833电机驱动芯片：** 具有电流控制功能的双H桥电机驱动器，可以驱动两个直流电机、一个双极步进电机、电磁阀或其他电感负载。每个H桥的输出驱动器块由N沟道功率MOSFET组成，配置为H桥以驱动电机绕组。每个H桥包括调节或限制绕组电流的电路。
带有故障输出引脚的内部停机功能是用于过大电流保护、短路保护、欠压锁定和超温。还提供了低功耗睡眠模式。我们来看一下DRV8833电机驱动芯片驱动两个直流电机的电路图和示意图：
![Img](/media/img-20230330104317.png)
![Img](/media/img-20230330104518.png)
如果想更深了解DRV8833电机驱动芯片，可以查看我们提供的芯片规格书，在资料的“附件”文件夹里。
![Img](/media/img-20230518105747.png)

3.规格参数：
- 逻辑部分输入电压：DC 5V
- 驱动部分输入电压：DC 5V
- 逻辑部分工作电流：<30mA
- 驱动部分工作电流：<2A
- 最大耗散功率：10W（T=80℃）
- 电机转速：5V  200 rpm / min
- 电机驱动形式：DRV8833双路H桥驱动
- 控制信号输入电平：高电平2.3V<Vin<5V  ，低电平-0.3V<Vin<1.5V
- 工作温度：-25~130℃

4.驱动小车运行原理：
根据上面电机驱动板的电路图和示意图，我们知道左电机的方向引脚在GPIO33，调速引脚在GPIO26；右电机的方向引脚在GPIO32，调速引脚在GPIO25，按照以下表格的运动逻辑，就可以知道如何通过控制数字口，PWM口控制2个电机转动，从而实现智能小车的行走。其中PWM值范围为0-255，设置数字越大，电机转动越快。

|功能|GPIO33|GPIO26（PWM）|左电机|GPIO32|GPIO25（PWM）|右电机|
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|前进|LOW|200|正转|LOW|200|正转|
|后退|HIGH|55|反转|HIGH|55|反转|
|左转|HIGH|55|反转|LOW|200|正转|
|右转|LOW|200|正转|HIGH|55|反转|
|停止|LOW|0|停止|LOW|0|停止|

5.实验代码：

```
//*************************************************************************************
/*
 项目 05 电机驱动和调速
 电机向前、向后、向左、向右转动
*/ 
###define left_ctrl  33  //定义左电机方向控制引脚gpio33
###define left_pwm  26   //定义左电机PWM控制引脚gpio26
###define right_ctrl  32 //定义右电机方向控制引脚gpio32
###define right_pwm  25  //定义右电机PWM控制引脚gpio25

void setup()
{
  pinMode(left_ctrl,OUTPUT);//设置左电机方向控制引脚为输出.
  ledcSetup(0, 1200, 8);//设置LEDC通道1频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(26, 0);  //将LEDC通道1绑定到指定的左电机引脚gpio26上以实现输出.
  pinMode(right_ctrl,OUTPUT);//设置右电机方向控制引脚为输出.
  ledcSetup(1, 1200, 8);//设置LEDC通道为2频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(25, 1);  //将LEDC通道2绑定到指定的右电机引脚gpio25上以实现输出.
}

void loop()
{ 
  //前进
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
  delay(2000);//延时2秒
  
  //后退
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 50); //LEDC通道1绑定到指定的左电机输出PWM值为50.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 50); //LEDC通道2绑定到指定的右电机输出PWM值为50.
  delay(2000);//延时2秒.
  
  //左转
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 55); //LEDC通道1绑定到指定的左电机输出PWM值为55.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
  delay(2000);//延时2秒.
  
  //右转
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 55); //LEDC通道2绑定到指定的右电机输出PWM值为55.
  delay(2000);//延时2秒.
  
  //停止
  digitalWrite(left_ctrl,LOW);//左电机方向控制引脚低电平.
  ledcWrite(0, 0); //LEDC通道1绑定到指定的左电机输出PWM值为0.
  digitalWrite(right_ctrl,LOW);//右电机方向控制引脚低电平.
  ledcWrite(1, 0); //LEDC通道2绑定到指定的右电机输出PWM值为0.
  delay(2000);//延时2秒.
}
//*************************************************************************************
```
6.实验现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），小车安上电池，并且将电源开关拨到ON端，上电后，小车前进2秒，后退2秒，左转2秒，右转2秒，停止2秒，循环。

7.调速说明：
![Img](/media/img-20230330111630.png)HIGH相当于PWM值255，50是PWM值，是可以调整的。此代码中的差值是205，上下差值越大，电机转速越快，我们可以通过调整PWM值达到调节电机转速。如果将50调为0，上下差值就变成255，电机转速达到最大；如果将50调为255时，上下差值就变成0，电机转速为0，电机就不转动了。上下差值为正值时，电机反转。
![Img](/media/img-20230330111952.png)
LOW相当于PWM值0，255是PWM值，是可以调整的。此代码中的差值是255，上下差值越大，电机转速越快，我们可以通过调整PWM值达到调节电机转速。如果将255调为100，上下差值就变成100，电机转速减慢；如果上下差值为255，电机转速达到最大；如果将255调为0时，上下差值变为0，电机就不转动了。上下差值为负值时，电机正转。

### 项目06: 超声波传感器

1.实验简介：

小车上有个超声波传感器，超声波传感器是一种非常实惠的距离传感器，它可以检测前方是否存在障碍物，并且检测出传感器与障碍物的详细距离。它的原理和蝙蝠飞行的原理一样，就是超声波传感器发送出一种频率很高的超声波信号，通常正常人耳朵的听力的声波范围是20Hz~20kHz，人类无法听到。这些超声波的信号若是碰到障碍物，就会立刻反射回来，在接收到返回的信息之后，通过判断发射信号和接收信号的时间差，计算出传感器和障碍物的距离。超声波传感器主要用于各种机器人项目中的物体躲避和测距，也常被用于水位传感，甚至作为一个停车传感器。
在本实验中，我们使用超声波传感器来测量距离，并将数据打印在串口监视器上。

2.元件知识：
**HC-SR04超声波传感器：** 像蝙蝠一样使用声纳来确定与物体的距离，它提供了精准的非接触范围检测，高精度和稳定的读数。它的操作不受阳光或黑色材料的影响，就像精密的照相机(在声学上像布料这样比较软的材料很难被探测到)。它带有超声波发射器和接收器。

**参数：**
- 工作电压:+5V DC
- 静态电流: <2mA
- 工作电流: 15mA
- 有效角度: <15°
- 距离范围: 2cm – 400 cm
- 精度: 0.3 cm
- 测量角度: 30 degree
- 触发输入脉宽: 10us

**原理：**

最常用的超声测距的方法是回声探测法，如图：
![Img](/media/img-20230330113755.png)
超声波发射器向某一方向发射超声波，在发射时刻的同时计数器开始计时，超声波在空气中传播，途中碰到障碍物面阻挡就立即反射回来，超声波接收器收到反射回的超声波就立即停止计时。超声波也是一种声波，其声速V与温度有关。一般情况下超声波在空气中的传播速度为340m/s，根据计时器记录的时间t，就可以计算出发射点距障碍物面的距离s，即：s=340t/2：
(1)采用IO口TRIG触发测距，给至少10us的高电平信号;
(2)模块自动发送8个40khz的方波，自动检测是否有信号返回；
(3)有信号返回，通过ECHO输出一个高电平，单片机读取到高电平持续的时间就是超声波从发射到返回的时间。
![Img](/media/img-20230330112930.png)
超声波模块的电路图：
![Img](/media/img-20230330112940.png)

3.实验接线：
|超声波传感器| 小车PCB板 |
| :--: | :--: |
|Vcc|5V|
|Trig|S2（GPIO5）|
|Echo|S1（GPIO18）|
| Gnd |G|
![Img](/media/img-20230508095958.png)

4.实验代码：
超声波传感器的Trig引脚是由ESP32主板的GPIO5控制，Echo引脚是由ESP32主板的GPIO18控制。

```
//**********************************************************************************
/*
项目 06 超声波测距
超声波探测物体距离
*/
###define trigPin 5 // 定义trigPin为gpio5.
###define echoPin 18 // 定义 echoPin为gpio18.
###define MAX_DISTANCE 700 // 最大传感器距离额定为400-500cm。
//timeOut= 2*MAX_DISTANCE /100 /340 *1000000 = MAX_DISTANCE*58.8
float timeOut = MAX_DISTANCE * 60; 
int soundVelocity = 340; // 定义声速=340m/s
void setup() {
 pinMode(trigPin,OUTPUT);// 设置trigPin为输出模式
 pinMode(echoPin,INPUT); // 设置echoPin为输入模式
 Serial.begin(115200); // 打开串口监视器，设置波特率为115200.
}
void loop() {
 delay(100); // 延时 100ms . 
 Serial.printf("Distance: ");
 Serial.print(getSonar()); // 以厘米为单位获取距离并打印结果
 Serial.println("cm");
}
float getSonar() {
 unsigned long pingTime;
 float distance;
 // 使trigPin输出高电平持续10us触发HC_SR04
 digitalWrite(trigPin, HIGH); 
 delayMicroseconds(10);
 digitalWrite(trigPin, LOW);
 // 等待HC-SR04返回高电平，并测量此等待时间
 pingTime = pulseIn(echoPin, HIGH, timeOut); 
 // 根据时间计算距离
 distance = (float)pingTime * soundVelocity / 2 / 10000; 
 return distance; // 返回距离值
}
//**********************************************************************************
```
5.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，当把一个物体放在超声波传感器前面移动时(远近)，它会检测到物体的距离，该值将显示在串口监视器上。
![Img](/media/img-20230413080456.png)









### 项目07: 跟随我
![Img](/media/img-20230518083845.png)

1.实验简介：
在上面实验中，我们已经了解了8*8点阵、电机驱动和调速、超声波传感器、舵机等硬件知识，那么在本实验中，我们将结合它们打造一款跟随小车! 在电路设计过程中，我们可以利用超声波传感器来检测小车与前方物体的距离。通过测量距离控制电机的旋转，从而控制小车的运动状态，使小车跟随物体运动。
2.工作原理：
|检测|检测前方物体的距离（单位：cm）|
| :--: | :--: |
|条件1|距离＜8|
|状态|小车后退|
|条件2|8≤距离<13|
|状态|小车停止|
|条件3|13≤距离<35|
|状态|小车前进|
|条件3|距离≥35|
|状态|小车停止|

3.流程图：
![Img](/media/img-20230330120246.png)

4.实验代码：

```
//*************************************************************************************
/*
Project 07: 跟随我
Car follows the object
*/ 
//电机
###define left_ctrl  33  //定义左电机方向控制引脚gpio33.
###define left_pwm  26   //定义左电机PWM控制引脚gpio26.
###define right_ctrl  32 //定义右电机方向控制引脚gpio32.
###define right_pwm  25  //定义右电机PWM控制引脚gpio25.

//超声波传感器
###define TRIG_PIN 5 // 定义超声波的信号输入在gpio5.
###define ECHO_PIN 18 //定义超声波的信号输出在gpio18.
long distance; //定义距离变量

//舵机
int channel_PWM = 3; // 舵机通道
// 舵机频率，那么周期也就是1/50，也就是20ms ，PWM一共有16个通道，0-7位高速通道由80Mhz时钟驱动，后面8个为低速通道由1Mhz时钟驱动.
int freq_PWM = 50;
// PWM分辨率，取值为 0-20 之间  ，这里填写为10，那么后面的ledcWrite 这个里面填写的pwm值就在0-2的10次方之间，也就是0-1024，如果是要求不高的东西你可以直接拿1000去算了.
int resolution_PWM = 10;
// 绑定的IO，在下面的绑定函数里面会用到，绑定之后这个IO就会变成我们PWM的输出口.
const int servopin = 4;//定义舵机的IO脚位在gpio4.

void setup() {
  Serial.begin(115200); //设置波特率为115200.
  pinMode(left_ctrl,OUTPUT);//设置左电机方向控制引脚为输出.
  ledcSetup(0, 1200, 8);//设置LEDC通道0频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(26, 0);  //将LEDC通道0绑定到指定的左电机引脚gpio26上以实现输出.
  pinMode(right_ctrl,OUTPUT);//设置右电机方向控制引脚为输出.
  ledcSetup(1, 1200, 8);//设置LEDC通道1频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(25, 1);  //将LEDC通道1绑定到指定的右电机引脚gpio25上以实现输出.
  
  pinMode(TRIG_PIN,OUTPUT);//设置TRIG_PIN为输出.
  pinMode(ECHO_PIN,INPUT);//设置ECHO_PIN为输入.
  
  ledcSetup(3, 50, 10); // 设置舵机通道3频率为50,PWM分辨率为10.
  ledcAttachPin(4, 3);  //将 LEDC 通道绑定到指定 IO 口上以实现输出.
  ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，设置舵机初始角度为90°.
  delay(300);
}

void loop() {
  distance = checkdistance();//获取超声波测量的距离.
  Serial.print(distance);//发送脉冲，以厘米计算距离并打印结果.
  Serial.println("cm");
  if(distance<8)//如果距离小于8
  {
    back();//后退
  }
  else if((distance>=8)&&(distance<13))//如果距离大于等于8，小于13.
  {
    Stop();//停止
  }
  else if((distance>=13)&&(distance<35))//如果距离大于等于13，小于35.
  {
    front();//跟随
  }
  else//如果以上都不是
  {
    Stop();//停止
  }
}

float checkdistance() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  float distance = pulseIn(ECHO_PIN, HIGH) / 58.00;
  delay(10);
  return distance;
}
   
void front()//定义前进的状态
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道0绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道1绑定到指定的右电机输出PWM值为200.
}
void back()//定义后退的状态
{
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 100); //LEDC通道0绑定到指定的左电机输出PWM值为100.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 100); //LEDC通道1绑定到指定的右电机输出PWM值为100.
}
void Stop()//定义停止的状态
{
  digitalWrite(left_ctrl,LOW);//左电机方向控制引脚低电平.
  ledcWrite(0, 0); //LEDC通道0绑定到指定的左电机输出PWM值为0.
  digitalWrite(right_ctrl,LOW);//右电机方向控制引脚低电平.
  ledcWrite(1, 0); //LEDC通道1绑定到指定的右电机输出PWM值为0.
}
//*************************************************************************************
```
5.实验现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>）,小车安上电池，并且将电源开关拨到ON端，上电后，小车可以随着前方障碍物的移动而移动（只能在一条线直上，不能转弯）。# 项目08: 躲避障碍物
![Img](/media/img-20230518083634.png)

1.实验简介：
在上一实验中，我们制作了一个超声波跟随小车。实际上，利用同样硬件，我只需要更改一个测试代码就可以将跟随小车变为避障小车。那超声波避障小车，是怎么实现的呢？当然也是通过超声波传感器的测距来实现的。通过超声波传感器检测机器人前方障碍物，然后根据这一个数据获得机器人运动方向。

2.工作原理：
![Img](/media/img-20230330121032.png)

3.流程图：
![Img](/media/img-20230330131159.png)

4.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“<span style="color: rgb(0, 209, 0);">HT16K33_Lib_For_ESP32</span>”，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

5.实验代码：

```
//*************************************************************************************
/*
项目 08: 躲避障碍物
*/  
###include "HT16K33_Lib_For_ESP32.h"  //定义8*8点阵模块函数库.

//点阵
//定义点阵的引脚在GPIO21,GPIO22
###define SDA 21
###define SCL 22
ESP32_HT16K33 matrix = ESP32_HT16K33();
//数组，用于储存图案的数据，可以自己算也可以从取摸工具中得到
byte front[8]={0x12,0x24,0x48,0x90,0x90,0x48,0x24,0x12};
byte back[8]={0x48,0x24,0x12,0x09,0x09,0x12,0x24,0x48};
byte left[8]={0x18,0x24,0x42,0x99,0x24,0x42,0x81,0x00};
byte right[8]={0x00,0x81,0x42,0x24,0x99,0x42,0x24,0x18};
byte stop1[8]={0x00,0x00,0x00,0xfd,0xfd,0x00,0x00,0x00};
byte result[8][8];

//电机
###define left_ctrl  33  //定义左电机方向控制引脚gpio33.
###define left_pwm  26   //定义左电机PWM控制引脚gpio26.
###define right_ctrl  32 //定义右电机方向控制引脚gpio32.
###define right_pwm  25  //定义右电机PWM控制引脚gpio25.

//超声波传感器
###define TRIG_PIN 5 // 定义超声波的信号输入在gpio5.
###define ECHO_PIN 18 //定义超声波的信号输出在gpio18.
long distance,a1,a2;//定义三个距离变量

//舵机
int channel_PWM = 3; // 舵机通道
// 舵机频率，那么周期也就是1/50，也就是20ms ，PWM一共有16个通道，0-7位高速通道由80Mhz时钟驱动，后面8个为低速通道由1Mhz时钟驱动.
int freq_PWM = 50;
// PWM分辨率，取值为 0-20 之间  ，这里填写为10，那么后面的ledcWrite 这个里面填写的pwm值就在 0 - 2的10次方 之间 也就是 0-1024 ，如果是要求不高的东西你可以直接拿1000去算了.
int resolution_PWM = 10;
// 绑定的IO，在下面的绑定函数里面会用到，绑定之后这个IO就会变成我们PWM的输出口.
const int servopin = 4;//定义舵机的IO脚位在gpio4.

void setup() {
  Serial.begin(9600);
  pinMode(left_ctrl,OUTPUT);//设置左电机方向控制引脚为输出.
  ledcSetup(0, 1200, 8);//设置LEDC通道0频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(26, 0);  //将LEDC通道0绑定到指定的左电机引脚gpio26上以实现输出.
  pinMode(right_ctrl,OUTPUT);//设置右电机方向控制引脚为输出.
  ledcSetup(1, 1200, 8);//设置LEDC通道为1频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(25, 1);  //将LEDC通道1绑定到指定的右电机引脚gpio25上以实现输出.
  
  pinMode(TRIG_PIN,OUTPUT);//设置TRIG_PIN为输出.
  pinMode(ECHO_PIN,INPUT);//设置ECHO_PIN为输入.
  
  ledcSetup(3, 50, 10); // 设置舵机通道3频率为50,PWM分辨率为10.
  ledcAttachPin(4, 3);  //将 LEDC 通道绑定到指定 IO 口上以实现输出.
  ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，此时舵机转到90°.
  delay(300);
  
  matrix.init(0x70, SDA, SCL);//初始化点阵
  matrix.clear(); //点阵清屏
}
 
void loop()
 {
  avoid();//运行避障主程序
}

float checkdistance() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  float distance = pulseIn(ECHO_PIN, HIGH) / 58.00;
  delay(10);
  return distance;
}

void avoid()
{
  distance = checkdistance(); //获取超声波距离的值
  Serial.println(distance);
  if((distance < 10)&&(distance != 0))//如果距离小于10且大于0
  {
    car_Stop();//停止
    matrix.clear();
    matrix.showLedMatrix(stop1,0,0);//点阵显示停止图案
    matrix.show();//点阵显示停止图案
    delay(200);
    ledcWrite(channel_PWM, 128);  //20ms高电平为2.5ms左右 ，也就是2.5/20*1024，此时舵机转到180°.
    delay(300);
    a1=checkdistance();//测量距离
    delay(200);
    ledcWrite(channel_PWM, 25);  //20ms高电平为0.5ms左右 ，也就是0.5/20*1024，此时舵机转到0°.
    delay(300);
    a2=checkdistance();//测量距离
    delay(200);
    if(a1 > a2)//比较距离，如果左边大于右边
    {
      car_left();//向左转
      matrix.clear();
      matrix.showLedMatrix(left,0,0);//点阵显示向左图案
      matrix.show();//点阵显示向左图案
      ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，此时舵机转到90°.
      delay(300);
      matrix.clear();
      matrix.showLedMatrix(front,0,0);//点阵显示向前图案
      matrix.show();//点阵显示向前图案
    }
    else//如果右边大于左边
    {
      car_right();//向右转
      matrix.clear();
      matrix.showLedMatrix(right,0,0);//点阵显示向右图案
      matrix.show();//点阵显示向右图案
      ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，此时舵机转到90°.
      delay(300);
      matrix.clear();
      matrix.showLedMatrix(front,0,0);//点阵显示前进图案
      matrix.show();//点阵显示前进图案
    }
  }
  else//如果以上都不是
  {
    car_front();//前进
    matrix.clear();
    matrix.showLedMatrix(front,0,0);//点阵显示前进图案
    matrix.show();//点阵显示前进图案
  }
}

void car_front()//定义前进的状态
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道0绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void car_back()//定义后退的状态
{
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 50); //LEDC通道0绑定到指定的左电机输出PWM值为50.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 50); //LEDC通道1绑定到指定的右电机输出PWM值为50.
}
void car_left()//定义左转的状态
{
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 200); //LEDC通道0绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道1绑定到指定的右电机输出PWM值为200.
}
void car_right()//定义右转的状态
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道0绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 200); //LEDC通道1绑定到指定的右电机输出PWM值为200.
}
void car_Stop()//定义停止的状态
{
  digitalWrite(left_ctrl,LOW);//左电机方向控制引脚低电平.
  ledcWrite(0, 0); //LEDC通道0绑定到指定的左电机输出PWM值为0.
  digitalWrite(right_ctrl,LOW);//右电机方向控制引脚低电平.
  ledcWrite(1, 0); //LEDC通道1绑定到指定的右电机输出PWM值为0.
}
//*************************************************************************************
```
6.实验现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>）,小车安上电池，并且将电源开关拨到ON端，上电后，小车可以自动避障。# 项目09: 红外循迹读值

1.实验简介：
小车上有2个红外循迹，实际上就是2对ST188L3红外对管，常应用于循迹小车循线。红外循迹可以用来检测黑白线，在本实验中，我们使用ST188L3红外对管来检测黑白线，并将数据打印在串口监视器上。

2.元件知识：
**红外循迹传感器：** 红外循迹传感器的红外对管分为两部分，一部分是红外发射端，另一部分是红外接收端。
![Img](/media/img-20230522172021.png)
黑线或黑色物体对红外线有很好的吸收效果。当红外循迹发射端向黑线发射时，发射的红外线被吸收而未形成反射信号，红外循迹接收端未接收到信号，这样红外循迹输出高电平(1);白线或白色物体对红外线没有吸收作用，红外循迹发射端的红外信号会反射回接收端，这样红外循迹输出低电平(0)。

下表给出了小车底板上的红外循迹传感器检测不同颜色物体的所有情况下的数值。其中检测到黑线、黑色物体或无物体代表1，检测到白线或白色物体代表0。
![Img](/media/img-20230522173140.png)
|左边红外循迹传感器|右边红外循迹传感器|值（二进制）|
| :--: | :--: | :--: |
|0|0|00|
|0|1|01|
|1|0|10|
|1|1|11|

<span style="color: rgb(255, 76, 65);">警告：反射式光学传感器(包括红外循迹)应避免在阳光等有红外干扰的环境中使用。阳光中含有许多不可见光，如红外线和紫外线。在强光环境下，反射式光学传感器不能正常工作。</span>

3.实验代码：
小车PCB板上的左边红外循迹是由ESP32主板的GPIO17控制，右边红外循迹是由ESP32主板的GPIO16控制。

```
//*************************************************************************************
/*
项目 09: 读取循迹值
*/ 
###define tracking_left  17  //定义左红外循迹引脚gpio17
###define tracking_right  16  //定义右红外循迹引脚gpio16
int L_val,R_val; //定义左,右红外循迹两个变量

void setup() {
 Serial.begin(115200); //设置波特率为115200
 pinMode(tracking_left, INPUT); //设置左红外循迹引脚为输入模式
 pinMode(tracking_right, INPUT); //设置右红外循迹引脚为输入模式
}

void loop() {
 L_val = digitalRead(tracking_left); //读取左红外循迹的值
 R_val = digitalRead(tracking_right); //读取右红外循迹的值
 Serial.print("L_val: "); //串口打印字符串L_val
 Serial.print(L_val); //串口打印L_val值
 Serial.print("    "); //串口打印空格
 Serial.print("R_val: "); //串口打印字符串R_val
 Serial.println(R_val); //串口打印R_val值
 delay(300); //延时0.3秒
}
//*************************************************************************************
```

4.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，在小车的红外循迹下面放个黑色的东西，移动它，你会看到不同的指示灯亮起来，同时在串口监视器上看到红外循迹读取的值。<span style="color: rgb(255, 76, 65);">旋转电位器可调节灵敏度，将指示灯调节至亮与不亮的临界点时，灵敏度最高。</span>
![Img](/media/img-20230413080656.png)

### 项目10: 循线行走
![Img](/media/img-20230518082944.png)

1.实验简介：
在前面的项目中，我们详细的介绍了在上面实验中，我们已经了解了电机驱动和调速、红外循迹等硬件知识。在本实验中，小车会根据红外循迹传送的数值做出不同的动作。

2.工作原理：
|左边红外循迹传感器|右边红外循迹传感器|值（二进制）|动作|
| :--: | :--: | :--: | :--: |
|0|0|00|停止|
|0|1|01|向右转|
|1|0|10|向左转|
|1|1|11|向前走|
![Img](/media/img-20230522175919.png)

3.流程图：
![Img](/media/img-20230330133157.png)

4.实验代码：

```
//*************************************************************************************
/*
项目 10: 循迹小车
*/

//电机
###define left_ctrl  33  //定义左电机方向控制引脚gpio33
###define left_pwm  26   //定义左电机PWM控制引脚gpio26
###define right_ctrl  32 //定义右电机方向控制引脚gpio32
###define right_pwm  25  //定义右电机PWM控制引脚gpio25

//红外循迹
###define tracking_left  17  //定义左红外循迹引脚gpio17
###define tracking_right  16  //定义右红外循迹引脚gpio16
int L_val,R_val;//定义左,右红外循迹两个变量

//舵机
int channel_PWM = 3; // 舵机通道
// 舵机频率，那么周期也就是1/50，也就是20ms ，PWM一共有16个通道，0-7位高速通道由80Mhz时钟驱动，后面8个为低速通道由1Mhz时钟驱动.
int freq_PWM = 50;
// PWM分辨率，取值为 0-20 之间  ，这里填写为10，那么后面的ledcWrite 这个里面填写的pwm值就在 0 - 2的10次方 之间 也就是 0-1024 ，如果是要求不高的东西你可以直接拿1000去算了.
int resolution_PWM = 10;
// 绑定的IO，在下面的绑定函数里面会用到，绑定之后这个IO就会变成我们PWM的输出口.
const int servopin = 4;//定义舵机的IO脚位在gpio4.

void setup() {
  pinMode(left_ctrl,OUTPUT);//设置左电机方向控制引脚为输出.
  ledcSetup(0, 1200, 8);//设置LEDC通道1频率为20，PWM分辨率为8，即占空比256.
  ledcAttachPin(26, 0);  //将LEDC通道1绑定到指定的左电机引脚gpio26上以实现输出.
  pinMode(right_ctrl,OUTPUT);//设置右电机方向控制引脚为输出.
  ledcSetup(1, 1200, 8);//设置LEDC通道为2频率为20，PWM分辨率为8，即占空比256.
  ledcAttachPin(25, 1);  //将LEDC通道2绑定到指定的右电机引脚gpio25上以实现输出.
  
  pinMode(tracking_left, INPUT); //设置左红外循迹引脚为输入
  pinMode(tracking_right, INPUT); //设置右红外循迹引脚为输入
 
  ledcSetup(3, 50, 10); // 设置舵机通道3频率为50,PWM分辨率为10.
  ledcAttachPin(4, 3);  //将 LEDC 通道绑定到指定 IO 口上以实现输出.
  ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，此时舵机转动90°.
  delay(300);
}

void loop() 
{
  tracking(); //运行主程序
}

void tracking()
{
  L_val = digitalRead(tracking_left);//读取左红外循迹的值
  R_val = digitalRead(tracking_right);//读取右红外循迹的值
  if((L_val == 1)&&(R_val == 1))//如果左,右红外循迹都读到黑线
  {
    front();//小车前进
  }
  else if((L_val == 1)&&(R_val == 0))//否则如果左红外循迹读到黑线，右红外循迹没有
  {
    left();//小车左转
  }
  else if((L_val == 0)&&(R_val == 1))//如果右红外循迹读到黑线，左红外循迹没有
  {
    right();//小车右转
  }
  else//如果左,右红外循迹都没有读到黑线
  {
    Stop();//小车停止
   }
}

void front()//定义前进的状态
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 130); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 130); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void left()//定义左转的状态
{
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 135); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 80); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void right()//定义右转的状态
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 80); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 135); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void Stop()//定义停止的状态
{
  digitalWrite(left_ctrl,LOW);//左电机方向控制引脚低电平.
  ledcWrite(0, 0); //LEDC通道1绑定到指定的左电机输出PWM值为0.
  digitalWrite(right_ctrl,LOW);//右电机方向控制引脚低电平.
  ledcWrite(1, 0); //LEDC通道2绑定到指定的右电机输出PWM值为0.
}
//*************************************************************************************

```
5.实验现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），小车安上电池，并且将电源开关拨到ON端，上电后，然后把小车放在循迹轨道（**我们提供有**）上，小车就开始根据红外循迹传送的数值做出不同的动作。


### 项目11: 读取光敏传感器的值

1.实验简介：

我们都知道人类可以通过自己的眼睛在黑暗中寻找光源，那么机器人是怎样完成这项任务呢？让机器人完成这项任务首先需要给机器人安装上能看见光亮的眼睛，即光敏传感器，这样就能让机器人通过光源的强弱来寻找光源。我们的小车上左右各装有1个光敏传感器，当外界环境光线的强、弱发生变化的时候，光敏传感器的电阻也跟随发生相应的改变，并把这种变化传输给小车上的ESP32主板，ESP32主板就像人的大脑一样可以判断和思考，指挥着小车寻找光线。两个光敏传感器不停的检测是否有光线，检测到光线后就判断左、右两边哪个方向的光线较强，最后就指挥小车向着光线强的方向前进。

在本实验中，我们将了解光敏传感器的工作原理。

2.元件知识：
**光敏传感器：** 它主要采用光敏电阻元件，该电阻元件电阻大小随着光照强度的变化而变化。传感器信号端连接单片机模拟口，当光线越强时，模拟口电压越大，即单片机的模拟值也大；反之，光照强度越弱时，模拟口电压越小，即单片机的模拟值也小。这样，就可以利用光敏传感器读取对应的模拟值来反映环境光线强度。

3.实验接线：
通过前面的安装接线知道，两个光敏传感器的信号脚位已经接到了ESP32主板的GPIO34和GPIO35，下面我们就利用接到GPIO34的光敏传感器来完成下面的实验，首先我们来读取模拟值。
|左边光敏传感器| 小车PCB板 |
| :--: | :--: |
| G| G |
| V| V |
|S|S（GPIO34）|
![Img](/media/img-20230508101203.png)

4.实验代码：
左边光敏传感器是由ESP32主板的GPIO34控制。

```
//*************************************************************************************
/*
项目 11:读取光照强度值
*/
###define PHOTOSENSITIVE_PIN 34 //定义ESP32读取光敏的引脚
int photosensitiveADC;        //定义一个变量来存储ADC值

void setup()
{
  pinMode(PHOTOSENSITIVE_PIN, INPUT);//配置输入模式的引脚
  Serial.begin(115200);          //初始化串口，波特率设置为115200
}

void loop()
{
  photosensitiveADC = analogRead(PHOTOSENSITIVE_PIN);//读取光敏电阻值
  Serial.print("photosensitiveADC: ");
  Serial.println(photosensitiveADC);         //打印光敏电阻值
  delay(500);
}
//*************************************************************************************

```

5.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，当光线增强时，串口监视器显示的模拟值增大；反之，串口监视器显示的模拟值减小。
![Img](/media/img-20230413081000.png)













### 项目12: 寻光车
![Img](/media/img-20230518083512.png)

1.实验简介：
前面实验已经了解过光敏传感器的工作原理、电机驱动与调速，在本实验中，我们利用光敏传感器检测光线强弱来实现小车寻光效果，哪边光敏传感器接收到的光线较强，小车就往那边走。

2.工作原理：
|左光敏传感器的模拟值|右光敏传感器的模拟值|功能|
| :--: | :--: | :--: |
|大于3000|大于3000|向前移动|
|大于3000|小于等于3000|向左移动|
|小于等于3000|大于3000|向右移动|
|小于3000|小于3000|停止|

3.实验接线：
|左边光敏传感器|小车PCB板|右边光敏传感器|小车PCB板|
| :--: | :--: | :--: | :--: |
| G| G| G | G |
| V | V | V | V |
| S |S（GPIO34）| S |S（GPIO35）|
![Img](/media/img-20230508101203.png)  ![Img](/media/img-20230508101729.png)
4.流程图：
![Img](/media/img-20230330134855.png)

5.实验代码：
左边光敏传感器是由ESP32主板的GPIO34控制，右边光敏传感器是由ESP32主板的GPIO35控制。

```
//*************************************************************************************
/*
项目 12:寻光车
*/ 

//电机
###define left_ctrl  33  //定义左电机方向控制引脚gpio33.
###define left_pwm  26   //定义左电机PWM控制引脚gpio26.
###define right_ctrl  32 //定义右电机方向控制引脚gpio32.
###define right_pwm  25  //定义右电机PWM控制引脚gpio25.

//左右光敏传感器
###define light_L_Pin  34   //定义左光敏传感器引脚gpio34
###define light_R_Pin  35   //定义右光敏传感器引脚gpio35
int left_light; 
int right_light;

//舵机
int channel_PWM = 3; // 舵机通道
// 舵机频率，那么周期也就是1/50，也就是20ms ，PWM一共有16个通道，0-7位高速通道由80Mhz时钟驱动，后面8个为低速通道由1Mhz时钟驱动.
int freq_PWM = 50;
// PWM分辨率，取值为 0-20 之间  ，这里填写为10，那么后面的ledcWrite 这个里面填写的pwm值就在 0 - 2的10次方 之间 也就是 0-1024 ，如果是要求不高的东西你可以直接拿1000去算了.
int resolution_PWM = 10;
// 绑定的IO，在下面的绑定函数里面会用到，绑定之后这个IO就会变成我们PWM的输出口.
const int servopin = 4;//定义舵机的IO脚位在gpio4.

void setup(){
  Serial.begin(115200); //设置波特率为115200.
  pinMode(light_L_Pin, INPUT); //设置左光敏传感器引脚为输入
  pinMode(light_R_Pin, INPUT); //设置右光敏传感器引脚为输入
  
  pinMode(left_ctrl,OUTPUT);//设置左电机方向控制引脚为输出.
  ledcSetup(0, 1200, 8);//设置LEDC通道1频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(26, 0);  //将LEDC通道1绑定到指定的左电机引脚gpio26上以实现输出.
  pinMode(right_ctrl,OUTPUT);//设置右电机方向控制引脚为输出.
  ledcSetup(1, 1200, 8);//设置LEDC通道2频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(25, 1);  //将LEDC通道2绑定到指定的右电机引脚gpio25上以实现输出.
  
  ledcSetup(3, 50, 10); // 设置舵机通道3频率为50,PWM分辨率为10.
  ledcAttachPin(4, 3);  //将 LEDC 通道绑定到指定 IO 口上以实现输出.
  ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，设置舵机初始角度为90°.
  delay(300);
}

void loop(){
  left_light = analogRead(light_L_Pin);//读取左光敏传感器的值
  right_light = analogRead(light_R_Pin);//读取右光敏传感器的值
  Serial.print("left_light_value = ");
  Serial.println(left_light);
  Serial.print("right_light_value = ");
  Serial.println(right_light);
  if (left_light > 3000 && right_light > 3000) //左,右光敏传感器测到的范围值
  {  
    Car_front(); //小车前进
  } 
  else if (left_light > 3000 && right_light <= 3000)  //左,右光敏传感器测到的范围值
  {
    Car_left(); //小车左转
  } 
  else if (left_light <= 3000 && right_light > 3000) //左,右光敏传感器测到的范围值
  {
    Car_right(); //小车右转
  } 
  else  //除以上情况之外
  {
    Car_Stop(); //小车停止
  }
}

void Car_front()
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void Car_left()
{
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void Car_right()
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void Car_Stop()
{
  digitalWrite(left_ctrl,LOW);//左电机方向控制引脚低电平.
  ledcWrite(0, 0); //LEDC通道1绑定到指定的左电机输出PWM值为0.
  digitalWrite(right_ctrl,LOW);//右电机方向控制引脚低电平.
  ledcWrite(1, 0); //LEDC通道2绑定到指定的右电机输出PWM值为0.
}
//*************************************************************************************
```
6.实验现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），小车安上电池，并且将电源开关拨到ON端，上电后，用手电筒光对着小车上光敏传感器，寻光车能够跟随着光移动。











### 项目13: 红外遥控和接收

1.实验简介：
红外遥控在日常生活中随处可见，它被用来控制各种家电，如电视、音响、录影机和卫星信号接收器。红外遥控是由红外发射和红外接收系统组成的，也就是一个红外遥控器、红外接收器和一个能解码的单片机组成的，小车上有个红外接收器。

在本实验中，使用红外接收器和红外遥控器相结合，读取红外遥控器上的按键值并将按键值打印在串口监视器上。

2.元件知识：
**红外(IR)遥控器：** 是一种具有一定数量按钮的设备。按下不同的按钮会使位于遥控器前端的红外发射管以不同的编码发送红外信号。红外遥控技术应用广泛，如电视、空调等。因此，在当今科技发达社会，红外遥控技术使你切换电视节目和调节空调温度都很方便。
我们使用的遥控器如下所示：
该红外遥控器采用NEC编码，信号周期为110ms。
![Img](/media/img-20230330135918.png)

**红外(IR)接收器：** 它是一种元件，可以接收红外光，所以可以用它来检测红外遥控器发出的红外光信号。红外接收器解调接收到的红外光信号，并将其转换回二进制，然后将信息传递给微控制器。
红外信号调制过程图：
![Img](/media/img-20230331103440.png)

3.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“<span style="color: rgb(0, 209, 0);">IRremoteESP8266</span>”，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

4.实验代码：
小车PCB板上的红外接收器是由ESP32主板的GPIO19控制。

```
//**********************************************************************************
/*
项目13:红外遥控及红外接收
*/
###include <Arduino.h>
###include <IRremoteESP8266.h>
###include <IRrecv.h>
###include <IRutils.h>

const uint16_t recvPin = 19;  // 红外接收引脚
IRrecv irrecv(recvPin);  // 创建用于接收类的类对象
decode_results results;   // 创建解码结果类对象

void setup()
{
  Serial.begin(115200); // 初始化串口，波特率设置为115200
  irrecv.enableIRIn(); // 开始接收信号
}

void loop() {
  if (irrecv.decode(&results)) {
    serialPrintUint64(results.value, HEX);
    Serial.println("");
    irrecv.resume(); //释放IRremote并接收下一个值.
  }
  delay(100);
}
//**********************************************************************************
```
5.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200.
按下红外遥控器上的一个按钮，你会在串口显示器上看到一个代码。多次按下相同的按钮以确保你拥有该按钮的正确代码。如果看到FFFFFFFF，请忽略它。
![Img](/media/img-20230413081734.png)


写下红外遥控器与每个按钮相关联的代码，因为你稍后将需要这些信息。
![Img](/media/img-20230413081911.png)



### 项目14: 红外遥控车
![Img](/media/img-20230518082547.png)

1.实验简介：
在上面实验中，我们已经了解了8*8点阵、电机驱动和调速、红外接收器和红外遥控器等硬件知识，在本实验中，我们将使用红外遥控器和红外接收器来控制小车做一些动作。

2.工作原理：
|按键|按键代码|功能|
| :--: | :--: | :--: |
|![Img](/media/img-20230330140558.png)| FF629D |前进，点阵屏显示“前进”图案|
|![Img](/media/img-20230330140636.png)| FFA857 | 后退，点阵屏显示“后退”图案 |
|![Img](/media/img-20230330140706.png)| FF22DD | 向左转，点阵屏显示“左转”图案|
|![Img](/media/img-20230330140736.png)| FFC23D |向右转，点阵屏显示“右转”图案 |
|![Img](/media/img-20230330140806.png)| FF02FD|停止，点阵屏显示“停止”图案 |

3.流程图：
![Img](/media/img-20230330140847.png)

4.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“<span style="color: rgb(0, 209, 0);">IRremoteESP8266</span>”，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

5.实验代码：

```
//*************************************************************************************
/*
项目 14:红外控制小车
*/ 
###include <Arduino.h>
###include <IRremoteESP8266.h>
###include <IRrecv.h>
###include <IRutils.h>
###include <HT16K33_Lib_For_ESP32.h>

//红外接收
const uint16_t RECV_PIN = 19;  //红外接收引脚
IRrecv irrecv(RECV_PIN); //初始化红外接收引脚
unsigned long irr_val;
decode_results results; //创建一个解码结果类对象

//点阵
//定义点阵的引脚在GPIO21,GPIO22
###define SDA 21
###define SCL 22
ESP32_HT16K33 matrix = ESP32_HT16K33();
//数组，用于储存图案的数据，可以自己算也可以从取摸工具中得到
byte front[8]={0x12,0x24,0x48,0x90,0x90,0x48,0x24,0x12};
byte back[8]={0x48,0x24,0x12,0x09,0x09,0x12,0x24,0x48};
byte left[8]={0x18,0x24,0x42,0x99,0x24,0x42,0x81,0x00};
byte right[8]={0x00,0x81,0x42,0x24,0x99,0x42,0x24,0x18};
byte stop1[8]={0x00,0x00,0x00,0xfd,0xfd,0x00,0x00,0x00};

//电机
###define left_ctrl  33  //定义左电机方向控制引脚gpio33.
###define left_pwm  26   //定义左电机PWM控制引脚gpio26.
###define right_ctrl  32 //定义右电机方向控制引脚gpio32.
###define right_pwm  25  //定义右电机PWM控制引脚gpio25.

//舵机
int channel_PWM = 3; // 舵机通道
// 舵机频率，那么周期也就是1/50，也就是20ms ，PWM一共有16个通道，0-7位高速通道由80Mhz时钟驱动，后面8个为低速通道由1Mhz时钟驱动.
int freq_PWM = 50;
// PWM分辨率，取值为 0-20 之间  ，这里填写为10，那么后面的ledcWrite 这个里面填写的pwm值就在 0 - 2的10次方之间 也就是 0-1024 ，如果是要求不高的东西你可以直接拿1000去算了.
int resolution_PWM = 10;
// 绑定的IO，在下面的绑定函数里面会用到，绑定之后这个IO就会变成我们PWM的输出口.
const int servopin = 4;//定义舵机的IO脚位在gpio4.

void setup() {
  Serial.begin(115200);//打开串口，波特率115200
  pinMode(left_ctrl,OUTPUT);//设置左电机方向控制引脚为输出.
  ledcSetup(0, 1200, 8);//设置LEDC通道1频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(26, 0);  //将LEDC通道1绑定到指定的左电机引脚gpio26上以实现输出.
  pinMode(right_ctrl,OUTPUT);//设置右电机方向控制引脚为输出.
  ledcSetup(1, 1200, 8);//设置LEDC通道为2频率为1200，PWM分辨率为8，即占空比256.
  ledcAttachPin(25, 1);  //将LEDC通道2绑定到指定的右电机引脚gpio25上以实现输出.
  
  // In case the interrupt driver crashes on setup, give a clue
  // to the user what's going on.
  irrecv.enableIRIn(); // 开始接收信号
  Serial.print("Enabling IRin");
  Serial.println(RECV_PIN);   //print the infrared receiving pin
  
  ledcSetup(3, 50, 10); // 设置舵机通道3频率为50,PWM分辨率为10.
  ledcAttachPin(4, 3);  //将 LEDC 通道绑定到指定 IO 口上以实现输出.
  ledcWrite(channel_PWM, 77);  //20ms高电平为1.5ms左右 ，也就是1.5/20*1024，此时舵机转到90°.
  delay(300);
  matrix.init(0x70, SDA, SCL);//初始化点阵
  matrix.clear(); //点阵清屏
}

void loop() {
  if (irrecv.decode(&results)) {
    // print() & println() can't handle printing long longs. (uint64_t)
    irr_val = results.value;
    serialPrintUint64(irr_val, HEX);
    Serial.println("");
    switch(irr_val)
    {
      case 0xFF629D : 
        car_front(); 
        matrix.clear();
        matrix.showLedMatrix(front,0,0);//点阵显示向前图案
        matrix.show();//点阵显示向前图案  
        break;
      case 0xFFA857 : 
        car_back(); 
        matrix.clear();
        matrix.showLedMatrix(back,0,0);//点阵显示向后图案
        matrix.show();//点阵显示向后图案
        break;
      case 0xFF22DD : 
        car_left(); 
        matrix.clear();
        matrix.showLedMatrix(left,0,0);//点阵显示向左图案
        matrix.show();//点阵显示向左图案
        break; 
      case 0xFFC23D : 
        car_right();
        matrix.clear();
        matrix.showLedMatrix(right,0,0);//点阵显示向右图案
        matrix.show();//点阵显示向右图案
        break;
      case 0xFF02FD : 
        car_Stop();
        matrix.clear();
        matrix.showLedMatrix(stop1,0,0);//点阵显示停止图案
        matrix.show();//点阵显示停止图案
        break;
    }
    irrecv.resume();  // Receive the next value
  }
  delay(100);
}


void car_front()//定义前进的状态
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void car_back()//定义后退的状态
{
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 50); //LEDC通道1绑定到指定的左电机输出PWM值为50.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 50); //LEDC通道2绑定到指定的右电机输出PWM值为50.
}
void car_left()//定义左转的状态
{
  digitalWrite(left_ctrl,HIGH); //左电机方向控制引脚高电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,LOW); //右电机方向控制引脚低电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void car_right()//定义右转的状态
{
  digitalWrite(left_ctrl,LOW); //左电机方向控制引脚低电平.
  ledcWrite(0, 200); //LEDC通道1绑定到指定的左电机输出PWM值为200.
  digitalWrite(right_ctrl,HIGH); //右电机方向控制引脚高电平.
  ledcWrite(1, 200); //LEDC通道2绑定到指定的右电机输出PWM值为200.
}
void car_Stop()//定义停止的状态
{
  digitalWrite(left_ctrl,LOW);//左电机方向控制引脚低电平.
  ledcWrite(0, 0); //LEDC通道1绑定到指定的左电机输出PWM值为0.
  digitalWrite(right_ctrl,LOW);//右电机方向控制引脚低电平.
  ledcWrite(1, 0); //LEDC通道2绑定到指定的右电机输出PWM值为0.
}
//*************************************************************************************
```

6.实验现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），小车安上电池，并且将电源开关拨到ON端，上电后，按下红外遥控器对应按键，小车跟着遥控器按下的按键做出相应的动作。

### 项目15: WIFI 工作模式

在如今科技高速发展的时代，人们的生活质量越来越好，生活节奏越来越快，开始有人觉得复杂多样的智能化设备控制起来十分麻烦，通过手机统一控制智能化设备这种方法逐渐得到了人们的青睐。这种方法是利用单片机通过wifi模块和Internet网络建立手机和智能化设备之间的连接以此来实现对智能化设备的远程控制。在本章中，我们将重点关注ESP32的WiFi基础设施。ESP32有3种不同的WiFi工作模式：Station模式、AP模式和AP+Station模式。所有WiFi编程项目在使用WiFi前必须配置WiFi运行模式，否则无法使用WiFi。

项目15.1: WIFI Station 模式

1.实验元件：
|![Img](/media/img-20230330141831.png)|![Img](/media/img-20230329114812.png)|
| :--: | :--: |
| USB 线 x1|ESP32x1|

2.实验接线：
使用USB线将ESP32主板连接到电脑上的USB口。
![Img](/media/img-20230330142518.png)

3.元件知识： 
**Station 模式：** 当ESP32选择Station模式时，它作为一个WiFi客户端。它可以连接路由器网络，通过WiFi连接与路由器上的其他设备通信。如下图所示，PC和路由器已经连接，ESP32如果要与PC通信，需要将PC和路由器连接起来。
![Img](/media/img-20230330143626.png)

4.实验代码：
由于各地的WiFi名称和密码是不同，所以在程序代码运行之前，用户需要在下图所示的框中输入正确的WiFi名称和密码。
![Img](/media/img-20230330144059.png)

```
//**********************************************************************************
/*
  项目 15.1: WiFi Station模式
  说明:使用ESP32连接到路由器
*/
###include <WiFi.h>
  
const char *ssid_Router     = "********"; //输入路由器名称
const char *password_Router = "********"; //输入路由器密码 

void setup(){
  Serial.begin(115200);
  delay(2000);
  Serial.println("Setup start");
  WiFi.begin(ssid_Router, password_Router);
  Serial.println(String("Connecting to ")+ssid_Router);
  while (WiFi.status() != WL_CONNECTED){
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected, IP address: ");
  Serial.println(WiFi.localIP());
  Serial.println("Setup End");
}
 
void loop() {
}
//**********************************************************************************
```
5.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，当ESP32成功连接到ssid_WiFi时，串行监视器将打印出WiFi分配给ESP32的IP地址。然后串口监视器窗口将显示如下：
![Img](/media/img-20230413083930.png)


项目15.2：WIFI AP 模式

1.实验元件&接线：
实验元件和实验接线与**项目15.1: WIFI Station 模式**相同。

2.元件知识：
**AP模式：** 当ESP32选择AP模式时，会创建一个独立于Internet的热点网络，等待其他WiFi设备连接。如下图所示，以ESP32为热点。如果手机或PC需要与ESP32通信，则必须连接到ESP32的热点。只有通过ESP32建立连接后才能进行通信。
![Img](/media/img-20230330144821.png)

3.实验代码：
在程序代码运行之前，你可以像下图所示对框中ESP32的AP名称和密码进行任何更改。当然，在默认情况下，你也可以不修改它。
![Img](/media/img-20230330145132.png)

```
//*************************************************************************************
/*
  项目 15.2: WiFi AP模式
  说明:设置ESP32为打开接入点
*/
###include <WiFi.h>

const char *ssid_AP     = "ESP32_Wifi"; //输入AP名称
const char *password_AP = "12345678"; //输入AP密码

IPAddress local_IP(192,168,1,100);//设置ESP32本身的IP地址
IPAddress gateway(192,168,1,10);   //设置ESP32本身的网关
IPAddress subnet(255,255,255,0);  //设置ESP32本身的子网掩码

void setup(){
  Serial.begin(115200);
  delay(2000);
  Serial.println("Setting soft-AP configuration ... ");
  WiFi.disconnect();
  WiFi.mode(WIFI_AP);
  Serial.println(WiFi.softAPConfig(local_IP, gateway, subnet) ? "Ready" : "Failed!");
  Serial.println("Setting soft-AP ... ");
  boolean result = WiFi.softAP(ssid_AP, password_AP);
  if(result){
    Serial.println("Ready");
    Serial.println(String("Soft-AP IP address = ") + WiFi.softAPIP().toString());
    Serial.println(String("MAC address = ") + WiFi.softAPmacAddress().c_str());
  }else{
    Serial.println("Failed!");
  }
  Serial.println("Setup End");
}
 
void loop() {
}
//*************************************************************************************
```
4.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，然后它将显示如下：
![Img](/media/img-20230413084002.png)

观察串口监视器打印信息时，打开手机WiFi扫描功能，可以看到ESP32上的ssid_AP，在本程序代码中称为“ESP32_Wifi”。你可以输入密码“12345678”连接它，也可以通过修改程序代码来修改它的AP名称和密码。
![Img](/media/img-20230330145323.png)


项目15.3：WIFI AP+Station模式

1.实验元件&接线：
实验元件和实验接线与**项目15.1: WIFI Station 模式**和**项目15.2: WIFI AP 模式**相同。
2.元件知识：

**AP+Station模式：** ESP32除AP模式和Station模式外，还可以同时使用AP模式和Station模式。此模式包含前两种模式的功能。打开ESP32的Station模式，将其连接到路由器网络，它可以通过路由器与Internet通信。同时开启其AP模式，创建热点网络。其他WiFi设备可以选择连接路由器网络或热点网络与ESP32通信。

3.实验代码：
类似于**项目15.1: WIFI Station 模式**和**项目15.2: WIFI AP 模式**，在运行程序代码之前，你需要修改下图框中显示的ssid_Router、password_Router、ssid_AP和password_AP。
![Img](/media/img-20230330145758.png)

```
//*************************************************************************************
/*
  项目 15.3: WiFi AP+Station模式
  描述:ESP32连接到用户的路由器，打开一个接入点
*/
###include <WiFi.h>
 
const char *ssid_Router     =  "********";  //输入路由器名称
const char *password_Router =  "********";  //输入路由器密码
const char *ssid_AP         =  "ESP32_Wifi"; //输入AP名称
const char *password_AP     =  "12345678";  //输入AP密码

void setup(){
  Serial.begin(115200);
  Serial.println("Setting soft-AP configuration ... ");
  WiFi.disconnect();
  WiFi.mode(WIFI_AP);
  Serial.println("Setting soft-AP ... ");
  boolean result = WiFi.softAP(ssid_AP, password_AP);
  if(result){
    Serial.println("Ready");
    Serial.println(String("Soft-AP IP address = ") + WiFi.softAPIP().toString());
    Serial.println(String("MAC address = ") + WiFi.softAPmacAddress().c_str());
  }else{
    Serial.println("Failed!");
  }
  
  Serial.println("\nSetting Station configuration ... ");
  WiFi.begin(ssid_Router, password_Router);
  Serial.println(String("Connecting to ")+ ssid_Router);
  while (WiFi.status() != WL_CONNECTED){
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected, IP address: ");
  Serial.println(WiFi.localIP());
  Serial.println("Setup End");
}

void loop() {
}
//*************************************************************************************
```
4.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，然后串口监视器窗口将显示如下：
![Img](/media/img-20230413084129.png)
(<span style="color: rgb(255, 76, 65);">如果打开串口监视器且设置波特率为115200之后，串口监视器窗口没有显示如下信息，可以按下ESP32主板上的复位键.</span>

在观察串口显示器打印信息时，打开手机WiFi扫描功能，可以在ESP32上看到ssid_AP。
![Img](/media/img-20230330150315.png)











### 项目16 读取APP按钮字符串

1.实验简介：
在前面的实验中，我们已经了解了ESP32的WIFI Station模式，WIFI AP模式和WIFI AP+Station模式等三种模式。
在本实验中，我们先使用ESP32的WIFI Station模式通过APP连接WIFI来读取APP上各功能按钮发送的字符。

2.安装APP

**安卓系统设备（手机/平板）APP：**

1.下载Beetlebot.apk文件

A. 我们提供了Android APP 的安装包：
![Img](/media/img-20230425082506.png)
现将文件夹中的Beetlebot.apk文件转移到安卓系统手机或平板上。

B. 或者使用手机浏览器中的扫描功能去扫二维码下载APP。
![Img](/media/img-20230506145736.png)

2.点击Beetlebot.apk文件进入安装页面，点击“允许”按钮，然后再点击“继续安装”按钮，安装完成后点击“打开”按钮就可以进入APP界面。
![Img](/media/img-20230506150200.png)
![Img](/media/img-20230506150422.png)
![Img](/media/img-20230506150539.png)
![Img](/media/img-20230330152214.png)

**IOS系统设备（手机/iPad）APP**
a.打开App Store。
![Img](/media/img-20230330152300.png)
b.在搜索框输入“**Beetlebot**”，点击搜索，出现下载界面，点击“![Img](/media/img-20230330152329.png)”，就可以下载安装Beetlebot的APP。接下来的操作和安卓系统类似的，可以参考上面安卓系统的步骤进行操作。

3.实验代码：

```
//*************************************************************************************
/*
项目16：读取APP按钮字符串
*/

// generated by KidsBlock
###include <Arduino.h>
###include <WiFi.h>
###include <ESPmDNS.h>
###include <WiFiClient.h>

String item = "0";
const char* ssid = "ChinaNet-2.4G-0DF0";
const char* password = "ChinaNet@233";
WiFiServer server(80);

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  server.begin();
  Serial.println("TCP server started");
  MDNS.addService("http", "tcp", 80);
}

void loop() {
  WiFiClient client = server.available();
  if (!client) {
      return;
  }
  while(client.connected() && !client.available()){
      delay(1);
  }
  String req = client.readStringUntil('\r');
  int addr_start = req.indexOf(' ');
  int addr_end = req.indexOf(' ', addr_start + 1);
  if (addr_start == -1 || addr_end == -1) {
      Serial.print("Invalid request: ");
      Serial.println(req);
      return;
  }
  req = req.substring(addr_start + 1, addr_end);
  item=req;
  Serial.println(item);
  String s;
  if (req == "/")
  {
      IPAddress ip = WiFi.localIP();
      String ipStr = String(ip[0]) + '.' + String(ip[1]) + '.' + String(ip[2]) + '.' + String(ip[3]);
      s = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<!DOCTYPE HTML>\r\n<html>Hello from ESP32 at ";
      s += ipStr;
      s += "</html>\r\n\r\n";
      Serial.println("Sending 200");
      client.println(s);
  }
  //client.print(s);
  client.stop();
}
//*************************************************************************************
```
<span style="color: rgb(255, 76, 65);">特别注意：</span>需要先将实验代码![Img](/media/img-20230330152503.png)中的用户Wifi名称和用户Wifi密码改成你们自己的Wifi名称和Wifi密码。

4.实验现象：
编译并上传代码到ESP32主板上（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），利用USB线上电后，再打开串口监视器![Img](/media/img-20230330103640.png)，设置波特率为115200，这样，串口监视器打印检测到的WiFi IP地址，然后打开WiFi APP。在WIFI按钮前面的文本框中输入检测到的WIFI IP地址（例如，下面串口监视器检测到的IP地址：192.168.1.137），再切换WiFi按钮来连接WiFi（白色WIFI按钮变成绿色WIFI按钮），同时WiFi IP地址前的文本框中会显示对应的WiFi IP地址“192.168.1.137”。这样，就说明APP已经连接上了WiFi。
![Img](/media/img-20230330152622.png)
用手分别点击APP上的各个功能按钮，然后串口监视器会打印接收到的对应字符。(<span style="color: rgb(255, 76, 65);">如果打开串口监视器且设置波特率为115200之后，串口监视器窗口没有显示如下信息，可以按下ESP32主板上的复位键![Img](/media/img-20230330150217.png)
</span>）
![Img](/media/img-20230330153222.png)






### 项目17 WIFI控制点阵屏

1.实验简介：
在前面的实验中，我们已经读取了APP按钮字符串。那么在本实验中，我们将使用ESP32的WIFI Station模式通过APP连接WIFI来控制小车上8×8点阵屏。

2.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“<span style="color: rgb(0, 209, 0);">HT16K33_Lib_For_ESP32</span>”，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

3.实验代码：
<span style="color: rgb(255, 76, 65);">特别注意：需要先将实验代码![Img](/media/img-20230406143547.png)中的用户Wifi名称和用户Wifi密码改成你们自己的Wifi名称和Wifi密码。</span>

```
//*************************************************************************************
/*
项目 17: WIFI 控制8*8点阵屏
*/

// generated by KidsBlock
###include <Arduino.h>
###include <WiFi.h>
###include <ESPmDNS.h>
###include <WiFiClient.h>
###include <HT16K33_Lib_For_ESP32.h>

String item = "0";
const char* ssid = "ChinaNet-2.4G-0DF0";
const char* password = "ChinaNet@233";
WiFiServer server(80);

//点阵
//定义点阵的引脚在GPIO21,GPIO22
###define SDA 21
###define SCL 22
ESP32_HT16K33 matrix = ESP32_HT16K33();
//数组，用于储存图案的数据，可以自己算也可以从取摸工具中得到
byte front[8]={0x12,0x24,0x48,0x90,0x90,0x48,0x24,0x12};
byte back[8]={0x48,0x24,0x12,0x09,0x09,0x12,0x24,0x48};
byte left[8]={0x18,0x24,0x42,0x99,0x24,0x42,0x81,0x00};
byte right[8]={0x00,0x81,0x42,0x24,0x99,0x42,0x24,0x18};
byte stop1[8]={0x00,0x00,0x00,0xfd,0xfd,0x00,0x00,0x00};

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  server.begin();
  Serial.println("TCP server started");
  MDNS.addService("http", "tcp", 80);

  matrix.init(0x70, SDA, SCL);// matrix init
  matrix.clear(); //clear
  matrix.setBrightness(10);
}

void loop() {
  WiFiClient client = server.available();
  if (!client) {
      return;
  }
  while(client.connected() && !client.available()){
      delay(1);
  }
  String req = client.readStringUntil('\r');
  int addr_start = req.indexOf(' ');
  int addr_end = req.indexOf(' ', addr_start + 1);
  if (addr_start == -1 || addr_end == -1) {
      Serial.print("Invalid request: ");
      Serial.println(req);
      return;
  }
  req = req.substring(addr_start + 1, addr_end);
  item=req;
  Serial.println(item);
  String s;
  if (req == "/")
  {
      IPAddress ip = WiFi.localIP();
      String ipStr = String(ip[0]) + '.' + String(ip[1]) + '.' + String(ip[2]) + '.' + String(ip[3]);
      s = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<!DOCTYPE HTML>\r\n<html>Hello from ESP32 at ";
      s += ipStr;
      s += "</html>\r\n\r\n";
      Serial.println("Sending 200");
      client.println(s);
  }
  else if(req == "/btn/i")
  {
    Serial.write('i');
    client.println(F("i"));
    matrix.showLedMatrix(front,0,0);//点阵显示向前图案
    matrix.show();//点阵显示向前图案 
  }
  else if(req == "/btn/j")
  {
    Serial.write('j');
    client.println(F("j"));
    matrix.showLedMatrix(stop1,0,0);//点阵显示向前图案
    matrix.show();//点阵显示向前图案 
  }
  else if(req == "/btn/k")
  {
    Serial.write('k');
    client.println(F("k"));
    matrix.showLedMatrix(back,0,0);//点阵显示向前图案
    matrix.show();//点阵显示向前图案 
  }
  //client.print(s);
  client.stop();
}
//*************************************************************************************
```

4.实验APP操作及现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），小车安上电池，并且将电源开关拨到ON端，上电后，打开APP，连接上WiFi，点击![Img](/media/img-20230330154408.png)按钮，小车前面的8×8点阵显示“向前”图案；点击![Img](/media/img-20230330154416.png)按钮，小车前面的8×8点阵显示“停止”图案；点击![Img](/media/img-20230330154423.png)按钮，小车前面的8×8点阵显示“向后”图案。

















### 项目18 WiFi控制多功能小车
![Img](/media/img-20230518083704.png)

1.实验简介：
在项目16和项目17中，我们学会了通过WiFi使小车与APP通讯，能打印出APP发送的信号并且控制了点阵显示不同图案。同样的方法，我们在本项目中将学习APP控制小车运动，点阵表情切换和RGB灯颜色切换等。

2.添加库文件：
首先我们先确保安装了库文件，不然代码会编译出错，这里需要将提供的库文件都要添加，如何安装库文件请参考“<span style="color: rgb(255, 76, 65);">开发环境配置</span>”文件。如果库文件已安装，就跳过这一步骤。
![Img](/media/img-20230518101152.png)

3.实验代码：
<span style="color: rgb(255, 76, 65);">特别注意：需要先将实验代码![Img](/media/img-20230406143547.png)中的用户Wifi名称和用户Wifi密码改成你们自己的Wifi名称和Wifi密码。</span>

由于代码比较长，请打开我们提供的示例代码“Project_18_WIFI_Control_Car”查看，如下图位置：
![Img](/media/img-20230518103157.png)

4.实验APP操作及现象：
编译并上传代码到ESP32主板（<span style="color: rgb(255, 76, 65);">如果上传代码不成功，可以在点击![Img](/media/img-20230330092521.png)后用手按住ESP32主板上的Boot键，出现上传进度百分比再松开Boot键![Img](/media/img-20230331144331.png)</span>），小车安上电池，并且将电源开关拨到ON端，上电后，打开APP，连接上WiFi，点击APP上的按钮来控制小车。

**APP操作，如下图：**
![Img](/media/img-20230330161926.png)












